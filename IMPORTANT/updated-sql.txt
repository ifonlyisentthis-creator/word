-- ============================================================================
-- AFTERWORD — COMPLETE SQL (Single Source of Truth)
-- Run this ONCE on a fresh Supabase project, or use individual sections
-- to patch an existing database.
--
-- Fixes applied vs original SQL.txt:
--   1. viewer_entry_status RPC — was completely missing (web viewer broken)
--   2. cleanup_sent_entries — changed from 7 days to 30 days per README §7.4
--   3. update_check_in — Lazarus fix: sets status='active' on check-in
--   4. Lifetime timer cap — 3650 days (10 years) per README §5.3.1.1
-- ============================================================================

-- ╔══════════════════════════════════════════════════════════════════════╗
-- ║  SECTION 1 — EXTENSIONS                                            ║
-- ╚══════════════════════════════════════════════════════════════════════╝

create extension if not exists pgcrypto;
create extension if not exists pg_cron;

-- ╔══════════════════════════════════════════════════════════════════════╗
-- ║  SECTION 2 — TABLES                                                ║
-- ╚══════════════════════════════════════════════════════════════════════╝

-- 2a. profiles
create table if not exists profiles (
  id                    uuid primary key references auth.users(id) on delete cascade,
  email                 text,
  sender_name           text        not null default 'Afterword',
  status                text        not null default 'active'
                        check (status in ('active','inactive','archived')),
  subscription_status   text        not null default 'free'
                        check (subscription_status in ('free','pro','lifetime','premium')),
  last_check_in         timestamptz not null default now(),
  timer_days            int         not null default 30,
  warning_sent_at       timestamptz,
  push_66_sent_at       timestamptz,
  push_33_sent_at       timestamptz,
  hmac_key_encrypted    text,
  last_entry_at         timestamptz,
  created_at            timestamptz not null default now(),
  updated_at            timestamptz not null default now()
);

-- 2a-patch. Add push notification tracking columns if missing (for existing databases)
alter table profiles add column if not exists push_66_sent_at timestamptz;
alter table profiles add column if not exists push_33_sent_at timestamptz;

-- 2b. vault_entries
create table if not exists vault_entries (
  id                          uuid primary key default gen_random_uuid(),
  user_id                     uuid        not null references auth.users(id) on delete cascade,
  title                       text        not null default 'Untitled',
  action_type                 text        not null default 'send'
                              check (action_type in ('send','destroy')),
  data_type                   text        not null default 'text'
                              check (data_type in ('text','audio')),
  status                      text        not null default 'active'
                              check (status in ('active','sending','sent')),
  payload_encrypted           text        not null,
  recipient_email_encrypted   text,
  data_key_encrypted          text        not null,
  hmac_signature              text        not null,
  audio_file_path             text,
  audio_duration_seconds      int,
  sent_at                     timestamptz,
  created_at                  timestamptz not null default now(),
  updated_at                  timestamptz not null default now()
);

create index if not exists vault_entries_user_status_idx
  on vault_entries(user_id, status);
create index if not exists vault_entries_audio_path_idx
  on vault_entries(audio_file_path);

-- 2c. push_devices (FCM tokens)
create table if not exists push_devices (
  id            uuid primary key default gen_random_uuid(),
  user_id       uuid        not null references auth.users(id) on delete cascade,
  fcm_token     text        not null unique,
  platform      text        not null,
  last_seen_at  timestamptz,
  created_at    timestamptz not null default now(),
  updated_at    timestamptz not null default now()
);

-- 2d. Payload length cap (~50 000 plaintext chars → ~70 000 encrypted)
do $$
begin
  if not exists (
    select 1 from pg_constraint
    where conname = 'vault_entries_payload_len_cap'
  ) then
    alter table vault_entries
      add constraint vault_entries_payload_len_cap
      check (char_length(payload_encrypted) <= 70000);
  end if;
end $$;

-- ╔══════════════════════════════════════════════════════════════════════╗
-- ║  SECTION 3 — UTILITY TRIGGER FUNCTIONS                             ║
-- ╚══════════════════════════════════════════════════════════════════════╝

-- 3a. Auto-set updated_at on any UPDATE
create or replace function set_updated_at()
returns trigger language plpgsql as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

drop trigger if exists profiles_set_updated_at on profiles;
create trigger profiles_set_updated_at
before update on profiles for each row execute function set_updated_at();

drop trigger if exists vault_entries_set_updated_at on vault_entries;
create trigger vault_entries_set_updated_at
before update on vault_entries for each row execute function set_updated_at();

drop trigger if exists set_push_devices_updated_at on push_devices;
create trigger set_push_devices_updated_at
before update on push_devices for each row execute function set_updated_at();

-- ╔══════════════════════════════════════════════════════════════════════╗
-- ║  SECTION 4 — RPC FUNCTIONS (called from Flutter / Web Viewer)      ║
-- ╚══════════════════════════════════════════════════════════════════════╝

-- 4a. update_check_in
--     • Resets the timer for the calling user
--     • LAZARUS FIX: always sets status = 'active' so returning users
--       (inactive / archived) are reactivated on check-in
--     • Clears warning_sent_at so the 24h email can fire again next cycle
--     • Clamps timer_days to subscription tier limits
create or replace function update_check_in(user_id uuid, timer_days int default null)
returns profiles language plpgsql security definer as $$
declare
  result profiles;
  sub text;
  effective_timer int;
  max_timer int;
begin
  if auth.uid() <> user_id then
    raise exception 'not authorized';
  end if;

  select subscription_status, p.timer_days
  into sub, effective_timer
  from profiles p where p.id = user_id;

  if sub is null then
    raise exception 'profile not found';
  end if;

  -- Determine max allowed timer per subscription tier
  if sub = 'lifetime' then
    max_timer := 3650;          -- 10 years
  elsif sub = 'pro' then
    max_timer := 365;           -- 1 year
  else
    max_timer := 30;            -- free: fixed 30 days
  end if;

  -- Clamp or force timer
  if sub not in ('pro','lifetime') then
    effective_timer := 30;
  elsif timer_days is not null then
    effective_timer := greatest(7, least(max_timer, timer_days));
  end if;

  update profiles
  set last_check_in   = now(),
      timer_days       = effective_timer,
      warning_sent_at  = null,
      push_66_sent_at  = null,
      push_33_sent_at  = null,
      status           = 'active'       -- ← LAZARUS FIX
  where id = user_id
  returning * into result;

  return result;
end;
$$;

-- 4b. update_sender_name
drop function if exists update_sender_name(text);
create or replace function update_sender_name(new_sender_name text)
returns profiles language plpgsql security definer as $$
declare result profiles;
begin
  update profiles
  set sender_name = coalesce(nullif(trim(new_sender_name), ''), 'Afterword')
  where id = auth.uid()
  returning * into result;
  return result;
end;
$$;

-- 4c. set_subscription_status (SERVICE ROLE ONLY — called by RevenueCat webhook)
create or replace function set_subscription_status(user_id uuid, subscription_status text)
returns profiles language plpgsql security definer as $$
declare result profiles;
begin
  if coalesce(current_setting('request.jwt.claim.role', true), '') <> 'service_role' then
    raise exception 'not authorized';
  end if;

  update profiles
  set subscription_status = lower(subscription_status)
  where id = user_id
  returning * into result;

  return result;
end;
$$;

revoke all on function set_subscription_status(uuid, text) from anon, authenticated;
grant execute on function set_subscription_status(uuid, text) to service_role;

-- 4d. cleanup_sent_entries (called by pg_cron AND heartbeat.py)
--     • Purges vault entries in 'sent' status older than 30 days (README §7.4)
--     • Marks profiles as 'archived' when they have no remaining active entries
create or replace function cleanup_sent_entries()
returns void language plpgsql security definer as $$
begin
  -- Delete audio storage objects for entries about to be purged
  delete from storage.objects
  where bucket_id = 'vault-audio'
    and name in (
      select audio_file_path from vault_entries
      where status = 'sent'
        and sent_at < now() - interval '30 days'
        and audio_file_path is not null
    );

  -- Purge sent entries older than 30 days
  delete from vault_entries
  where status = 'sent'
    and sent_at < now() - interval '30 days';

  -- Archive profiles that have no active/sending entries remaining
  update profiles p
  set status = 'archived'
  where p.status <> 'archived'
    and not exists (
      select 1 from vault_entries v
      where v.user_id = p.id and v.status in ('active','sending')
    )
    and exists (
      select 1 from vault_entries v
      where v.user_id = p.id and v.status = 'sent'
    ) is false
    and p.status = 'inactive';
end;
$$;

-- 4e. viewer_entry_status (called by web viewer — anonymous access)
--     Returns JSON: { state: 'available'|'expired'|'unavailable', sender_name? }
--     • 'available'   — entry exists and is in 'sent' status, ready for decryption
--     • 'expired'     — entry was purged or never existed (show compassionate message)
--     • 'unavailable' — entry exists but has not been sent yet
drop function if exists viewer_entry_status(uuid);
create or replace function viewer_entry_status(entry_id uuid)
returns json language plpgsql security definer as $$
declare
  rec record;
begin
  select ve.status, p.sender_name
  into rec
  from vault_entries ve
  join profiles p on p.id = ve.user_id
  where ve.id = entry_id;

  if not found then
    -- Entry was deleted (30-day purge) or never existed
    return json_build_object('state', 'expired', 'sender_name', null::text);
  end if;

  if rec.status = 'sent' then
    return json_build_object('state', 'available', 'sender_name', rec.sender_name);
  end if;

  -- Entry exists but hasn't been released yet (active/sending)
  return json_build_object('state', 'unavailable');
end;
$$;

-- Grant anon access so the web viewer (unauthenticated) can call this
grant execute on function viewer_entry_status(uuid) to anon;

-- ╔══════════════════════════════════════════════════════════════════════╗
-- ║  SECTION 5 — GUARD TRIGGERS (security enforcement)                 ║
-- ╚══════════════════════════════════════════════════════════════════════╝

-- 5a. Prevent clients from changing subscription_status directly
create or replace function guard_subscription_status()
returns trigger language plpgsql as $$
begin
  if new.subscription_status is distinct from old.subscription_status
     and coalesce(current_setting('request.jwt.claim.role', true), '') <> 'service_role' then
    raise exception 'subscription_status can only be changed by service role';
  end if;
  return new;
end;
$$;

drop trigger if exists protect_subscription_status on profiles;
create trigger protect_subscription_status
before update on profiles
for each row execute function guard_subscription_status();

-- 5b. Clamp timer_days to subscription tier limits
create or replace function guard_timer_days()
returns trigger language plpgsql as $$
declare
  max_timer int;
begin
  if new.timer_days is distinct from old.timer_days then
    if coalesce(current_setting('request.jwt.claim.role', true), '') <> 'service_role' then
      if old.subscription_status = 'lifetime' then
        max_timer := 3650;
        new.timer_days := greatest(7, least(max_timer, new.timer_days));
      elsif old.subscription_status = 'pro' then
        max_timer := 365;
        new.timer_days := greatest(7, least(max_timer, new.timer_days));
      else
        new.timer_days := 30;
      end if;
    end if;
  end if;
  return new;
end;
$$;

drop trigger if exists profiles_guard_timer_days on profiles;
create trigger profiles_guard_timer_days
before update on profiles
for each row execute function guard_timer_days();

-- 5c. Rate-limit vault entry creation: max 1 every 5 seconds
create or replace function enforce_entry_rate_limit()
returns trigger language plpgsql security definer as $$
declare
  last_ts timestamptz;
begin
  if new.user_id <> auth.uid() then
    raise exception 'not authorized';
  end if;

  select last_entry_at into last_ts
  from profiles
  where id = new.user_id
  for update;

  if last_ts is not null
     and clock_timestamp() - last_ts < interval '5 seconds' then
    raise exception 'rate limit';
  end if;

  return new;
end;
$$;

drop trigger if exists vault_entries_rate_limit on vault_entries;
create trigger vault_entries_rate_limit
before insert on vault_entries
for each row execute function enforce_entry_rate_limit();

-- 5d. Bump last_entry_at after insert (for rate limiting)
create or replace function bump_last_entry_at()
returns trigger language plpgsql security definer as $$
begin
  update profiles set last_entry_at = clock_timestamp()
  where id = new.user_id;
  return new;
end;
$$;

drop trigger if exists vault_entries_bump_last_entry on vault_entries;
create trigger vault_entries_bump_last_entry
after insert on vault_entries
for each row execute function bump_last_entry_at();

-- 5e. Enforce audio time bank (10 minutes = 600 seconds, lifetime only)
create or replace function enforce_audio_time_bank()
returns trigger language plpgsql security definer as $$
declare
  total_seconds int;
  sub text;
  new_duration int;
begin
  if new.data_type <> 'audio' then
    return new;
  end if;

  select subscription_status into sub
  from profiles
  where id = new.user_id;

  if sub <> 'lifetime' then
    raise exception 'audio vault is lifetime only';
  end if;

  new_duration := coalesce(new.audio_duration_seconds, 0);
  if new_duration <= 0 then
    raise exception 'audio duration required';
  end if;

  select coalesce(sum(audio_duration_seconds), 0)
  into total_seconds
  from vault_entries
  where user_id = new.user_id
    and data_type = 'audio'
    and status = 'active'
    and id <> new.id;

  if total_seconds + new_duration > 600 then
    raise exception 'audio time bank limit reached';
  end if;

  return new;
end;
$$;

drop trigger if exists vault_entries_audio_bank on vault_entries;
create trigger vault_entries_audio_bank
before insert or update on vault_entries
for each row execute function enforce_audio_time_bank();

-- ╔══════════════════════════════════════════════════════════════════════╗
-- ║  SECTION 6 — ROW LEVEL SECURITY (RLS)                              ║
-- ╚══════════════════════════════════════════════════════════════════════╝

alter table profiles enable row level security;
alter table vault_entries enable row level security;
alter table push_devices enable row level security;

-- 6a. profiles policies
drop policy if exists profiles_select_own on profiles;
drop policy if exists profiles_insert_own on profiles;
drop policy if exists profiles_update_own on profiles;
drop policy if exists profiles_delete_own on profiles;

create policy profiles_select_own on profiles
for select using (auth.uid() = id);

create policy profiles_insert_own on profiles
for insert with check (auth.uid() = id);

create policy profiles_update_own on profiles
for update using (auth.uid() = id) with check (auth.uid() = id);

create policy profiles_delete_own on profiles
for delete using (auth.uid() = id);

-- 6b. vault_entries policies
drop policy if exists entries_select_own on vault_entries;
drop policy if exists entries_select_sent_anon on vault_entries;
drop policy if exists entries_insert_own on vault_entries;
drop policy if exists entries_update_own on vault_entries;
drop policy if exists entries_delete_own on vault_entries;
drop policy if exists vault_entries_update on vault_entries;

-- Authenticated users can read all their own entries (any status)
create policy entries_select_own on vault_entries
for select using (auth.uid() = user_id);

-- Anonymous (web viewer) can read entries that have been sent
create policy entries_select_sent_anon on vault_entries
for select to anon using (status = 'sent');

-- Insert policy: enforces free tier limits, subscription gates
create policy entries_insert_own on vault_entries
for insert with check (
  auth.uid() = user_id
  and status = 'active'
  -- Destroy mode requires Pro/Lifetime
  and (
    action_type <> 'destroy'
    or exists (
      select 1 from profiles p
      where p.id = auth.uid() and p.subscription_status in ('pro','lifetime')
    )
  )
  -- Audio requires Lifetime
  and (
    data_type <> 'audio'
    or exists (
      select 1 from profiles p
      where p.id = auth.uid() and p.subscription_status = 'lifetime'
    )
  )
  -- Free users: max 3 active text items
  and (
    exists (
      select 1 from profiles p
      where p.id = auth.uid() and p.subscription_status in ('pro','lifetime')
    )
    or (
      select count(*) from vault_entries ve
      where ve.user_id = auth.uid()
        and ve.status = 'active'
        and ve.data_type = 'text'
    ) < 3
  )
);

-- Update policy: only active entries can be edited
create policy entries_update_own on vault_entries
for update using (auth.uid() = user_id and status = 'active')
with check (
  auth.uid() = user_id
  and status = 'active'
  -- Destroy mode requires Pro/Lifetime
  and (
    action_type <> 'destroy'
    or exists (
      select 1 from profiles p
      where p.id = auth.uid() and p.subscription_status in ('pro','lifetime')
    )
  )
  -- Audio requires Lifetime
  and (
    data_type <> 'audio'
    or exists (
      select 1 from profiles p
      where p.id = auth.uid() and p.subscription_status = 'lifetime'
    )
  )
);

-- Delete policy: users can delete their own entries in ANY status
-- (active entries + sent entries during the 30-day grace period)
create policy entries_delete_own on vault_entries
for delete using (auth.uid() = user_id);

-- 6c. push_devices policies
drop policy if exists push_devices_select_own on push_devices;
drop policy if exists push_devices_insert_own on push_devices;
drop policy if exists push_devices_update_own on push_devices;
drop policy if exists push_devices_delete_own on push_devices;

create policy push_devices_select_own on push_devices
for select to authenticated using (auth.uid() = user_id);

create policy push_devices_insert_own on push_devices
for insert to authenticated with check (auth.uid() = user_id);

create policy push_devices_update_own on push_devices
for update to authenticated
using (auth.uid() = user_id) with check (auth.uid() = user_id);

create policy push_devices_delete_own on push_devices
for delete to authenticated using (auth.uid() = user_id);

-- ╔══════════════════════════════════════════════════════════════════════╗
-- ║  SECTION 7 — STORAGE (Supabase Storage for encrypted audio)        ║
-- ╚══════════════════════════════════════════════════════════════════════╝

insert into storage.buckets (id, name, public)
values ('vault-audio', 'vault-audio', false)
on conflict (id) do nothing;

drop policy if exists vault_audio_read_owner on storage.objects;
drop policy if exists vault_audio_read_sent_anon on storage.objects;
drop policy if exists vault_audio_insert_lifetime on storage.objects;
drop policy if exists vault_audio_update_lifetime on storage.objects;
drop policy if exists vault_audio_delete_lifetime on storage.objects;

-- Authenticated owner can read their own audio files
create policy vault_audio_read_owner on storage.objects
for select to authenticated
using (bucket_id = 'vault-audio' and auth.uid() = owner);

-- Anonymous (web viewer) can read audio for sent entries
create policy vault_audio_read_sent_anon on storage.objects
for select to anon
using (
  bucket_id = 'vault-audio'
  and exists (
    select 1 from vault_entries ve
    where ve.audio_file_path = storage.objects.name
      and ve.status = 'sent'
  )
);

-- Only Lifetime users can upload audio
create policy vault_audio_insert_lifetime on storage.objects
for insert to authenticated
with check (
  bucket_id = 'vault-audio'
  and auth.uid() = owner
  and name like auth.uid() || '/%'
  and exists (
    select 1 from profiles p
    where p.id = auth.uid() and p.subscription_status = 'lifetime'
  )
);

-- Only Lifetime users can overwrite audio
create policy vault_audio_update_lifetime on storage.objects
for update to authenticated
using (bucket_id = 'vault-audio' and auth.uid() = owner)
with check (
  bucket_id = 'vault-audio'
  and auth.uid() = owner
  and name like auth.uid() || '/%'
  and exists (
    select 1 from profiles p
    where p.id = auth.uid() and p.subscription_status = 'lifetime'
  )
);

-- Only Lifetime users can delete audio
create policy vault_audio_delete_lifetime on storage.objects
for delete to authenticated
using (
  bucket_id = 'vault-audio'
  and auth.uid() = owner
  and exists (
    select 1 from profiles p
    where p.id = auth.uid() and p.subscription_status = 'lifetime'
  )
);

-- ╔══════════════════════════════════════════════════════════════════════╗
-- ║  SECTION 8 — COLUMN-LEVEL GRANTS (lockdown sensitive columns)      ║
-- ╚══════════════════════════════════════════════════════════════════════╝

-- Revoke broad UPDATE on profiles from client roles
revoke update on profiles from authenticated, anon;

-- Authenticated users can only update hmac_key_encrypted via direct UPDATE
-- (all other profile mutations go through security-definer RPCs)
grant update (hmac_key_encrypted) on profiles to authenticated;

-- Service role (heartbeat.py / webhooks) can update server-managed columns
grant update (subscription_status, status, warning_sent_at, push_66_sent_at, push_33_sent_at) on profiles to service_role;

-- ╔══════════════════════════════════════════════════════════════════════╗
-- ║  SECTION 9 — CRON JOBS                                             ║
-- ╚══════════════════════════════════════════════════════════════════════╝

-- Schedule daily cleanup at 03:00 UTC
select cron.unschedule(jobid) from cron.job where jobname = 'cleanup-sent-entries';
select cron.schedule(
  'cleanup-sent-entries',
  '0 3 * * *',
  $$select cleanup_sent_entries();$$
);

-- ============================================================================
-- END OF SQL
-- ============================================================================

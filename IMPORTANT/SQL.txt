ALL 12 SQL I RAN SO FAR IN SEQUENCE:


1:
create extension if not exists "pgcrypto";

create table if not exists profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  email text,
  sender_name text not null default 'Afterword',
  status text not null default 'active' check (status in ('active','inactive','archived')),
  subscription_status text not null default 'free'
    check (subscription_status in ('free','pro','lifetime','premium')),
  last_check_in timestamptz not null default now(),
  timer_days int not null default 30,
  warning_sent_at timestamptz,
  hmac_key_encrypted text,
  last_entry_at timestamptz,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create table if not exists vault_entries (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  title text not null default 'Untitled',
  action_type text not null default 'send' check (action_type in ('send','destroy')),
  data_type text not null default 'text' check (data_type in ('text','audio')),
  status text not null default 'active' check (status in ('active','sending','sent')),
  payload_encrypted text not null,
  recipient_email_encrypted text,
  data_key_encrypted text not null,
  hmac_signature text not null,
  audio_file_path text,
  audio_duration_seconds int,
  sent_at timestamptz,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index if not exists vault_entries_user_status_idx
  on vault_entries(user_id, status);
create index if not exists vault_entries_audio_path_idx
  on vault_entries(audio_file_path);

create or replace function set_updated_at()
returns trigger language plpgsql as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

create trigger profiles_set_updated_at
before update on profiles for each row execute function set_updated_at();

create trigger vault_entries_set_updated_at
before update on vault_entries for each row execute function set_updated_at();

create or replace function update_check_in(user_id uuid, timer_days int default null)
returns profiles language plpgsql security definer as $$
declare
  result profiles;
  sub text;
  effective_timer int;
begin
  if auth.uid() <> user_id then
    raise exception 'not authorized';
  end if;

  select subscription_status, timer_days into sub, effective_timer
  from profiles where id = user_id;

  if sub is null then
    raise exception 'profile not found';
  end if;

  if sub not in ('pro','lifetime') then
    effective_timer := 30;
  elsif timer_days is not null then
    effective_timer := greatest(7, least(365, timer_days));
  end if;

  update profiles
  set last_check_in = now(),
      timer_days = effective_timer,
      warning_sent_at = null
  where id = user_id
  returning * into result;

  return result;
end;
$$;

create or replace function update_sender_name(sender_name text)
returns profiles language plpgsql security definer as $$
declare result profiles;
begin
  update profiles
  set sender_name = coalesce(nullif(trim(sender_name), ''), 'Afterword')
  where id = auth.uid()
  returning * into result;
  return result;
end;
$$;

create or replace function set_subscription_status(user_id uuid, subscription_status text)
returns profiles language plpgsql security definer as $$
declare result profiles;
begin
  if auth.uid() <> user_id then
    raise exception 'not authorized';
  end if;

  update profiles
  set subscription_status = lower(subscription_status)
  where id = user_id
  returning * into result;

  return result;
end;
$$;

alter table profiles enable row level security;

create policy profiles_select_own on profiles
for select using (auth.uid() = id);

create policy profiles_insert_own on profiles
for insert with check (auth.uid() = id);

create policy profiles_update_own on profiles
for update using (auth.uid() = id) with check (auth.uid() = id);

create policy profiles_delete_own on profiles
for delete using (auth.uid() = id);

alter table vault_entries enable row level security;

create policy entries_select_own on vault_entries
for select using (auth.uid() = user_id);

create policy entries_select_sent_anon on vault_entries
for select to anon using (status = 'sent');

create policy entries_insert_own on vault_entries
for insert with check (
  auth.uid() = user_id
  and status = 'active'
  and (
    action_type <> 'destroy'
    or exists (
      select 1 from profiles p
      where p.id = auth.uid() and p.subscription_status in ('pro','lifetime')
    )
  )
  and (
    data_type <> 'audio'
    or exists (
      select 1 from profiles p
      where p.id = auth.uid() and p.subscription_status = 'lifetime'
    )
  )
  and (
    (select p.last_entry_at is null
        or now() - p.last_entry_at >= interval '5 seconds'
     from profiles p where p.id = auth.uid())
  )
);

create policy entries_update_own on vault_entries
for update using (auth.uid() = user_id and status = 'active')
with check (
  auth.uid() = user_id
  and status = 'active'
  and (
    action_type <> 'destroy'
    or exists (
      select 1 from profiles p
      where p.id = auth.uid() and p.subscription_status in ('pro','lifetime')
    )
  )
  and (
    data_type <> 'audio'
    or exists (
      select 1 from profiles p
      where p.id = auth.uid() and p.subscription_status = 'lifetime'
    )
  )
);

create policy entries_delete_own on vault_entries
for delete using (auth.uid() = user_id and status = 'active');

create or replace function bump_last_entry_at()
returns trigger language plpgsql security definer as $$
begin
  update profiles set last_entry_at = now() where id = new.user_id;
  return new;
end;
$$;

create trigger vault_entries_bump_last_entry
after insert on vault_entries for each row execute function bump_last_entry_at();

insert into storage.buckets (id, name, public)
values ('vault-audio', 'vault-audio', false)
on conflict (id) do nothing;

create policy vault_audio_read_owner on storage.objects
for select to authenticated
using (bucket_id = 'vault-audio' and auth.uid() = owner);

create policy vault_audio_read_sent_anon on storage.objects
for select to anon
using (
  bucket_id = 'vault-audio'
  and exists (
    select 1 from vault_entries ve
    where ve.audio_file_path = storage.objects.name
      and ve.status = 'sent'
  )
);

create policy vault_audio_insert_lifetime on storage.objects
for insert to authenticated
with check (
  bucket_id = 'vault-audio'
  and auth.uid() = owner
  and name like auth.uid() || '/%'
  and exists (
    select 1 from profiles p
    where p.id = auth.uid() and p.subscription_status = 'lifetime'
  )
);

create policy vault_audio_update_lifetime on storage.objects
for update to authenticated
using (bucket_id = 'vault-audio' and auth.uid() = owner)
with check (
  bucket_id = 'vault-audio'
  and auth.uid() = owner
  and name like auth.uid() || '/%'
  and exists (
    select 1 from profiles p
    where p.id = auth.uid() and p.subscription_status = 'lifetime'
  )
);

create policy vault_audio_delete_lifetime on storage.objects
for delete to authenticated
using (
  bucket_id = 'vault-audio'
  and auth.uid() = owner
  and exists (
    select 1 from profiles p
    where p.id = auth.uid() and p.subscription_status = 'lifetime'
  )
);


------------------------------------------------------------------

2:
create or replace function block_subscription_status_changes()
returns trigger language plpgsql as $$
begin
  if auth.role() <> 'service_role'
     and new.subscription_status is distinct from old.subscription_status then
    raise exception 'subscription_status is server-managed';
  end if;
  return new;
end;
$$;

drop trigger if exists profiles_block_sub_status on profiles;
create trigger profiles_block_sub_status
before update on profiles for each row
execute function block_subscription_status_changes();

-------------------------------------------------------------------

3.
drop policy if exists entries_insert_own on vault_entries;

create policy entries_insert_own on vault_entries
for insert with check (
  auth.uid() = user_id
  and status = 'active'
  and (
    action_type <> 'destroy'
    or exists (
      select 1 from profiles p
      where p.id = auth.uid() and p.subscription_status in ('pro','lifetime')
    )
  )
  and (
    data_type <> 'audio'
    or exists (
      select 1 from profiles p
      where p.id = auth.uid() and p.subscription_status = 'lifetime'
    )
  )
  and (
    exists (
      select 1 from profiles p
      where p.id = auth.uid() and p.subscription_status in ('pro','lifetime')
    )
    or (
      select count(*) from vault_entries ve
      where ve.user_id = auth.uid()
        and ve.status = 'active'
        and ve.data_type = 'text'
    ) < 3
  )
  and (
    (select p.last_entry_at is null
        or now() - p.last_entry_at >= interval '5 seconds'
     from profiles p where p.id = auth.uid())
  )
);

------------------------------------------------------------------

4.
create or replace function public.guard_subscription_status()
returns trigger
language plpgsql
as $$
begin
  if new.subscription_status is distinct from old.subscription_status
     and coalesce(current_setting('request.jwt.claim.role', true), '') <> 'service_role' then
    raise exception 'subscription_status can only be changed by service role';
  end if;
  return new;
end;
$$;

drop trigger if exists protect_subscription_status on profiles;
create trigger protect_subscription_status
before update on profiles
for each row execute function public.guard_subscription_status();

revoke all on function public.set_subscription_status(uuid, text) from anon, authenticated;
grant execute on function public.set_subscription_status(uuid, text) to service_role;

------------------------------------------------------------------------

5.
create or replace function public.enforce_audio_time_bank()
returns trigger
language plpgsql
security definer
as $$
declare
  total_seconds int;
begin
  if new.data_type <> 'audio' then
    return new;
  end if;

  if new.audio_duration_seconds is null then
    raise exception 'audio duration required';
  end if;

  select coalesce(sum(audio_duration_seconds), 0)
  into total_seconds
  from vault_entries
  where user_id = new.user_id
    and data_type = 'audio'
    and status = 'active'
    and id <> coalesce(new.id, gen_random_uuid());

  if total_seconds + new.audio_duration_seconds > 600 then
    raise exception 'audio time bank exceeded (10 minutes)';
  end if;

  return new;
end;
$$;

drop trigger if exists vault_entries_audio_time_bank on vault_entries;
create trigger vault_entries_audio_time_bank
before insert or update on vault_entries
for each row execute function public.enforce_audio_time_bank();

----------------------------------------------------------------

6.
create or replace function public.guard_timer_days()
returns trigger
language plpgsql
as $$
begin
  if new.timer_days is distinct from old.timer_days then
    if auth.role() <> 'service_role' then
      if exists (
        select 1 from profiles p
        where p.id = auth.uid()
          and p.subscription_status in ('pro','lifetime')
      ) then
        new.timer_days := greatest(7, least(365, new.timer_days));
      else
        new.timer_days := 30;
      end if;
    end if;
  end if;
  return new;
end;
$$;

drop trigger if exists profiles_guard_timer_days on profiles;
create trigger profiles_guard_timer_days
before update on profiles
for each row execute function public.guard_timer_days();

----------------------------------------------------------------

7.
drop trigger if exists profiles_block_sub_status on profiles;
drop trigger if exists protect_subscription_status on profiles;

create or replace function public.guard_subscription_status()
returns trigger
language plpgsql
as $$
begin
  if new.subscription_status is distinct from old.subscription_status
     and coalesce(current_setting('request.jwt.claim.role', true), '') <> 'service_role' then
    raise exception 'subscription_status can only be changed by service role';
  end if;
  return new;
end;
$$;

create trigger protect_subscription_status
before update on profiles
for each row execute function public.guard_subscription_status();

revoke all on function public.set_subscription_status(uuid, text) from anon, authenticated;
grant execute on function public.set_subscription_status(uuid, text) to service_role;

-------------------------------------------------------------------

8.
-- Ensure last_entry_at exists
alter table profiles
  add column if not exists last_entry_at timestamptz;

-- Rate-limit inserts: max 1 every 5 seconds
create or replace function enforce_entry_rate_limit()
returns trigger language plpgsql security definer as $$
declare
  last_ts timestamptz;
begin
  if new.user_id <> auth.uid() then
    raise exception 'not authorized';
  end if;

  select last_entry_at into last_ts
  from profiles
  where id = new.user_id
  for update;

  if last_ts is not null
     and clock_timestamp() - last_ts < interval '5 seconds' then
    raise exception 'rate limit';
  end if;

  return new;
end;
$$;

drop trigger if exists vault_entries_rate_limit on vault_entries;
create trigger vault_entries_rate_limit
before insert on vault_entries
for each row execute function enforce_entry_rate_limit();

-- Update last_entry_at after insert
create or replace function bump_last_entry_at()
returns trigger language plpgsql security definer as $$
begin
  update profiles set last_entry_at = clock_timestamp()
  where id = new.user_id;
  return new;
end;
$$;

drop trigger if exists vault_entries_bump_last_entry on vault_entries;
create trigger vault_entries_bump_last_entry
after insert on vault_entries
for each row execute function bump_last_entry_at();

-- Encrypted payload length cap (~50k plaintext)
do $$
begin
  if not exists (
    select 1 from pg_constraint
    where conname = 'vault_entries_payload_len_cap'
  ) then
    alter table vault_entries
      add constraint vault_entries_payload_len_cap
      check (char_length(payload_encrypted) <= 70000);
  end if;
end $$;

----------------------------------------------------------------

9.
create or replace function enforce_audio_time_bank()
returns trigger language plpgsql security definer as $$
declare
  total_seconds int;
  sub text;
  new_duration int;
begin
  if new.data_type <> 'audio' then
    return new;
  end if;

  select subscription_status into sub
  from profiles
  where id = new.user_id;

  if sub <> 'lifetime' then
    raise exception 'audio vault is lifetime only';
  end if;

  new_duration := coalesce(new.audio_duration_seconds, 0);
  if new_duration <= 0 then
    raise exception 'audio duration required';
  end if;

  select coalesce(sum(audio_duration_seconds), 0)
  into total_seconds
  from vault_entries
  where user_id = new.user_id
    and data_type = 'audio'
    and status = 'active'
    and id <> new.id;

  if total_seconds + new_duration > 600 then
    raise exception 'audio time bank limit reached';
  end if;

  return new;
end;
$$;

drop trigger if exists vault_entries_audio_bank on vault_entries;
create trigger vault_entries_audio_bank
before insert or update on vault_entries
for each row execute function enforce_audio_time_bank();

-------------------------------------------------------------

10.
create extension if not exists pg_cron;
select cron.schedule(
  'cleanup-sent-entries',
  '0 3 * * *',
  $$select cleanup_sent_entries();$$
);

-------------------------------------------------------------

11.
-- LOCKDOWN SENSITIVE PROFILE COLUMNS
revoke update on profiles from authenticated, anon;
grant update (hmac_key_encrypted) on profiles to authenticated;
grant update (subscription_status, status, warning_sent_at) on profiles to service_role;

-- SENT = READâ€‘ONLY (no edits)
drop policy if exists vault_entries_update on vault_entries;
create policy vault_entries_update on vault_entries
for update to authenticated
using (auth.uid() = user_id and status <> 'sent')
with check (auth.uid() = user_id and status <> 'sent');

-- CRON CLEANUP (sent older than 7 days)
create or replace function cleanup_sent_entries()
returns void language plpgsql security definer as $$
begin
  delete from vault_entries
  where status = 'sent'
    and sent_at < now() - interval '7 days';

  update profiles p
  set status = 'archived'
  where p.status <> 'archived'
    and not exists (
      select 1 from vault_entries v
      where v.user_id = p.id and v.status <> 'sent'
    );
end;
$$;

select cron.schedule(
  'cleanup-sent-entries',
  '0 3 * * *',
  $$select cleanup_sent_entries();$$
);

--------------------------------------------------------------------------

12.
create extension if not exists pgcrypto;
create extension if not exists pg_cron;

create table if not exists profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  email text,
  sender_name text not null default 'Afterword',
  status text not null default 'active' check (status in ('active','inactive','archived')),
  subscription_status text not null default 'free'
    check (subscription_status in ('free','pro','lifetime','premium')),
  last_check_in timestamptz not null default now(),
  timer_days int not null default 30,
  warning_sent_at timestamptz,
  hmac_key_encrypted text,
  last_entry_at timestamptz,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create table if not exists vault_entries (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  title text not null default 'Untitled',
  action_type text not null default 'send' check (action_type in ('send','destroy')),
  data_type text not null default 'text' check (data_type in ('text','audio')),
  status text not null default 'active' check (status in ('active','sending','sent')),
  payload_encrypted text not null,
  recipient_email_encrypted text,
  data_key_encrypted text not null,
  hmac_signature text not null,
  audio_file_path text,
  audio_duration_seconds int,
  sent_at timestamptz,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index if not exists vault_entries_user_status_idx
  on vault_entries(user_id, status);
create index if not exists vault_entries_audio_path_idx
  on vault_entries(audio_file_path);

create or replace function set_updated_at()
returns trigger language plpgsql as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

drop trigger if exists profiles_set_updated_at on profiles;
create trigger profiles_set_updated_at
before update on profiles for each row execute function set_updated_at();

drop trigger if exists vault_entries_set_updated_at on vault_entries;
create trigger vault_entries_set_updated_at
before update on vault_entries for each row execute function set_updated_at();

create or replace function update_check_in(user_id uuid, timer_days int default null)
returns profiles language plpgsql security definer as $$
declare
  result profiles;
  sub text;
  effective_timer int;
begin
  if auth.uid() <> user_id then
    raise exception 'not authorized';
  end if;

  select subscription_status, timer_days into sub, effective_timer
  from profiles where id = user_id;

  if sub is null then
    raise exception 'profile not found';
  end if;

  if sub not in ('pro','lifetime') then
    effective_timer := 30;
  elsif timer_days is not null then
    effective_timer := greatest(7, least(365, timer_days));
  end if;

  update profiles
  set last_check_in = now(),
      timer_days = effective_timer,
      warning_sent_at = null
  where id = user_id
  returning * into result;

  return result;
end;
$$;

create or replace function update_sender_name(sender_name text)
returns profiles language plpgsql security definer as $$
declare result profiles;
begin
  update profiles
  set sender_name = coalesce(nullif(trim(sender_name), ''), 'Afterword')
  where id = auth.uid()
  returning * into result;
  return result;
end;
$$;

create or replace function set_subscription_status(user_id uuid, subscription_status text)
returns profiles language plpgsql security definer as $$
declare result profiles;
begin
  if coalesce(current_setting('request.jwt.claim.role', true), '') <> 'service_role' then
    raise exception 'not authorized';
  end if;

  update profiles
  set subscription_status = lower(subscription_status)
  where id = user_id
  returning * into result;

  return result;
end;
$$;

revoke all on function public.set_subscription_status(uuid, text) from anon, authenticated;
grant execute on function public.set_subscription_status(uuid, text) to service_role;

create or replace function guard_subscription_status()
returns trigger language plpgsql as $$
begin
  if new.subscription_status is distinct from old.subscription_status
     and coalesce(current_setting('request.jwt.claim.role', true), '') <> 'service_role' then
    raise exception 'subscription_status can only be changed by service role';
  end if;
  return new;
end;
$$;

drop trigger if exists protect_subscription_status on profiles;
create trigger protect_subscription_status
before update on profiles
for each row execute function guard_subscription_status();

create or replace function guard_timer_days()
returns trigger language plpgsql as $$
begin
  if new.timer_days is distinct from old.timer_days then
    if auth.role() <> 'service_role' then
      if exists (
        select 1 from profiles p
        where p.id = auth.uid()
          and p.subscription_status in ('pro','lifetime')
      ) then
        new.timer_days := greatest(7, least(365, new.timer_days));
      else
        new.timer_days := 30;
      end if;
    end if;
  end if;
  return new;
end;
$$;

drop trigger if exists profiles_guard_timer_days on profiles;
create trigger profiles_guard_timer_days
before update on profiles
for each row execute function guard_timer_days();

create or replace function enforce_entry_rate_limit()
returns trigger language plpgsql security definer as $$
declare
  last_ts timestamptz;
begin
  if new.user_id <> auth.uid() then
    raise exception 'not authorized';
  end if;

  select last_entry_at into last_ts
  from profiles
  where id = new.user_id
  for update;

  if last_ts is not null
     and clock_timestamp() - last_ts < interval '5 seconds' then
    raise exception 'rate limit';
  end if;

  return new;
end;
$$;

drop trigger if exists vault_entries_rate_limit on vault_entries;
create trigger vault_entries_rate_limit
before insert on vault_entries
for each row execute function enforce_entry_rate_limit();

create or replace function bump_last_entry_at()
returns trigger language plpgsql security definer as $$
begin
  update profiles set last_entry_at = clock_timestamp()
  where id = new.user_id;
  return new;
end;
$$;

drop trigger if exists vault_entries_bump_last_entry on vault_entries;
create trigger vault_entries_bump_last_entry
after insert on vault_entries
for each row execute function bump_last_entry_at();

create or replace function enforce_audio_time_bank()
returns trigger language plpgsql security definer as $$
declare
  total_seconds int;
  sub text;
  new_duration int;
begin
  if new.data_type <> 'audio' then
    return new;
  end if;

  select subscription_status into sub
  from profiles
  where id = new.user_id;

  if sub <> 'lifetime' then
    raise exception 'audio vault is lifetime only';
  end if;

  new_duration := coalesce(new.audio_duration_seconds, 0);
  if new_duration <= 0 then
    raise exception 'audio duration required';
  end if;

  select coalesce(sum(audio_duration_seconds), 0)
  into total_seconds
  from vault_entries
  where user_id = new.user_id
    and data_type = 'audio'
    and status = 'active'
    and id <> new.id;

  if total_seconds + new_duration > 600 then
    raise exception 'audio time bank limit reached';
  end if;

  return new;
end;
$$;

drop trigger if exists vault_entries_audio_bank on vault_entries;
create trigger vault_entries_audio_bank
before insert or update on vault_entries
for each row execute function enforce_audio_time_bank();

do $$
begin
  if not exists (
    select 1 from pg_constraint
    where conname = 'vault_entries_payload_len_cap'
  ) then
    alter table vault_entries
      add constraint vault_entries_payload_len_cap
      check (char_length(payload_encrypted) <= 70000);
  end if;
end $$;

alter table profiles enable row level security;
alter table vault_entries enable row level security;

drop policy if exists profiles_select_own on profiles;
drop policy if exists profiles_insert_own on profiles;
drop policy if exists profiles_update_own on profiles;
drop policy if exists profiles_delete_own on profiles;

create policy profiles_select_own on profiles
for select using (auth.uid() = id);

create policy profiles_insert_own on profiles
for insert with check (auth.uid() = id);

create policy profiles_update_own on profiles
for update using (auth.uid() = id) with check (auth.uid() = id);

create policy profiles_delete_own on profiles
for delete using (auth.uid() = id);

drop policy if exists entries_select_own on vault_entries;
drop policy if exists entries_select_sent_anon on vault_entries;
drop policy if exists entries_insert_own on vault_entries;
drop policy if exists entries_update_own on vault_entries;
drop policy if exists entries_delete_own on vault_entries;
drop policy if exists vault_entries_update on vault_entries;

create policy entries_select_own on vault_entries
for select using (auth.uid() = user_id);

create policy entries_select_sent_anon on vault_entries
for select to anon using (status = 'sent');

create policy entries_insert_own on vault_entries
for insert with check (
  auth.uid() = user_id
  and status = 'active'
  and (
    action_type <> 'destroy'
    or exists (
      select 1 from profiles p
      where p.id = auth.uid() and p.subscription_status in ('pro','lifetime')
    )
  )
  and (
    data_type <> 'audio'
    or exists (
      select 1 from profiles p
      where p.id = auth.uid() and p.subscription_status = 'lifetime'
    )
  )
  and (
    exists (
      select 1 from profiles p
      where p.id = auth.uid() and p.subscription_status in ('pro','lifetime')
    )
    or (
      select count(*) from vault_entries ve
      where ve.user_id = auth.uid()
        and ve.status = 'active'
        and ve.data_type = 'text'
    ) < 3
  )
);

create policy entries_update_own on vault_entries
for update using (auth.uid() = user_id and status = 'active')
with check (
  auth.uid() = user_id
  and status = 'active'
  and (
    action_type <> 'destroy'
    or exists (
      select 1 from profiles p
      where p.id = auth.uid() and p.subscription_status in ('pro','lifetime')
    )
  )
  and (
    data_type <> 'audio'
    or exists (
      select 1 from profiles p
      where p.id = auth.uid() and p.subscription_status = 'lifetime'
    )
  )
);

create policy entries_delete_own on vault_entries
for delete using (auth.uid() = user_id);

insert into storage.buckets (id, name, public)
values ('vault-audio', 'vault-audio', false)
on conflict (id) do nothing;

drop policy if exists vault_audio_read_owner on storage.objects;
drop policy if exists vault_audio_read_sent_anon on storage.objects;
drop policy if exists vault_audio_insert_lifetime on storage.objects;
drop policy if exists vault_audio_update_lifetime on storage.objects;
drop policy if exists vault_audio_delete_lifetime on storage.objects;

create policy vault_audio_read_owner on storage.objects
for select to authenticated
using (bucket_id = 'vault-audio' and auth.uid() = owner);

create policy vault_audio_read_sent_anon on storage.objects
for select to anon
using (
  bucket_id = 'vault-audio'
  and exists (
    select 1 from vault_entries ve
    where ve.audio_file_path = storage.objects.name
      and ve.status = 'sent'
  )
);

create policy vault_audio_insert_lifetime on storage.objects
for insert to authenticated
with check (
  bucket_id = 'vault-audio'
  and auth.uid() = owner
  and name like auth.uid() || '/%'
  and exists (
    select 1 from profiles p
    where p.id = auth.uid() and p.subscription_status = 'lifetime'
  )
);

create policy vault_audio_update_lifetime on storage.objects
for update to authenticated
using (bucket_id = 'vault-audio' and auth.uid() = owner)
with check (
  bucket_id = 'vault-audio'
  and auth.uid() = owner
  and name like auth.uid() || '/%'
  and exists (
    select 1 from profiles p
    where p.id = auth.uid() and p.subscription_status = 'lifetime'
  )
);

create policy vault_audio_delete_lifetime on storage.objects
for delete to authenticated
using (
  bucket_id = 'vault-audio'
  and auth.uid() = owner
  and exists (
    select 1 from profiles p
    where p.id = auth.uid() and p.subscription_status = 'lifetime'
  )
);

revoke update on profiles from authenticated, anon;
grant update (hmac_key_encrypted) on profiles to authenticated;
grant update (subscription_status, status, warning_sent_at) on profiles to service_role;

create or replace function cleanup_sent_entries()
returns void language plpgsql security definer as $$
begin
  delete from vault_entries
  where status = 'sent'
    and sent_at < now() - interval '7 days';

  update profiles p
  set status = 'archived'
  where p.status <> 'archived'
    and not exists (
      select 1 from vault_entries v
      where v.user_id = p.id and v.status <> 'sent'
    );
end;
$$;

select cron.unschedule(jobid) from cron.job where jobname = 'cleanup-sent-entries';
select cron.schedule(
  'cleanup-sent-entries',
  '0 3 * * *',
  $$select cleanup_sent_entries();$$
);
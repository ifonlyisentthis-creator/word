## 1. Project Overview & Vibe



---



1.1 Target Platform: Android First. (Build using Flutter for cross-platform potential, but optimize testing and release strictly for Android initially).



1.2 The app is a "Dead Man‚Äôs Switch" and "Digital Time Capsule." It addresses the core anxiety: "What happens to my secrets if I die or disappear?"



1.3 The Core Function: Users set a "Check-in Timer" (Default: 30 Days). If they fail to open the app to reset the timer before it expires, the system automatically executes a pre-set protocol: either sending encrypted messages to specific beneficiaries or permanently destroying the data.



1.4 The Aesthetic: The UI must be minimalist, cinematic, and high-trust. Use deep OLED blacks, warm ambers/golds, and clean, high-end sans-serif typography. It should feel like a secure Swiss bank vault or a flight recorder, not a social media app.



1.5 The Hero Interaction (The Pulse): Instead of a standard button, the home screen features a "Breathing Ring" icon (a thin, abstract circle that slowly fades in and out).



1.6 Automatic Reset: The timer MUST reset automatically in the background (`initState`) the moment the app is opened. The user is not required to touch anything but for sake of users mind, we will add a "Soul Fire" button.



1.7 Manual Reset: The "Pulse" soul fire ring is there for psychological reassurance. If the user Long Presses the ring, it fills up visually, triggers a haptic vibration, and displays "Signal Verified." This confirms the timer has been reset.



---



## 2. The Tech Stack (Zero-Cost Architecture)



---



2.1 We must strictly adhere to this stack to ensure the app costs $0 to run until we generate revenue.



2.2 Mobile App: Flutter (Dart). Android First.



2.3 Backend & Auth: Supabase (Free Tier). Use PostgreSQL for the database and Supabase Auth for users.



2.4 Authentication Method: Google Sign-In ONLY.



2.5 Storage: Supabase Storage (for Audio).



2.6 Automation (The Heartbeat): GitHub Actions running a Python script. This runs once every 24 hours to check user timers.



2.7 Email Service: Resend API (Free Tier). To deliver the final "Unlock" emails.



2.8 Web Viewer: A simple HTML/JS page hosted on Vercel (Free). This allows beneficiaries to decrypt and view messages in their browser.



2.9 Payments: RevenueCat. To handle Subscriptions and Lifetime purchases.



2.10 Notifications: `flutter_local_notifications` (Primary) + Firebase Cloud Messaging (Secondary). Here we are mainly using push.



---



## 3. Core App Mechanics



---



3.1 The Master Timer: Every user has one main countdown timer. It starts counting immediately upon account creation.



3.2 Default Duration: 30 Days (Fixed for Free Users).



3.3 User Identity:



3.3.1 Sender Name: When signing up with Google, capture the default name but provide an Editable Field in Settings called "Sender Name." The user can change this to something recognizable like "Dad" or "Honey." This name is used in the Subject Line of final emails (e.g., "Message from Dad") to prevent them from looking like spam.



3.4 Account Retention: We never delete the User Profile (the account row in the database). We only delete the Vault Data. This allows users to return years later, log in via Google, and start fresh without re-registering.



3.5 The Vault (One-to-Many Routing):



3.5.1 Users can add multiple "Items" to their vault.



3.5.2 Per-Item Logic: Each item acts independently. The user must assign a specific Beneficiary Email for each item. (e.g., Bank Info sends to Wife; Confession sends to Brother).



3.5.3 Validation: If the Item Action is set to "Send," the user cannot save the item without entering a valid email address.



3.5.4 Abuse Protection: Rate limit creation to max 1 item every 5 seconds (client + server).



3.5.5 Per-Letter Cap: Silently cap each plaintext item at 50,000 characters to prevent crashes (no UI counter, don't tell user about it).



---



## 4. Security Architecture (The Trust Layer)



---



4.1 App Lock: Integrate `local_auth`. The app must require 6 digit PIN authentication immediately upon launch or resume.



4.2 Client-Side Encryption (Zero Knowledge): Use `flutter_sodium` or AES-256. All text and audio must be encrypted on the device before being uploaded. The server (and the Admin) must never see raw data.



4.3 Encrypted Metadata: The `recipient_email` column in the database must be encrypted. Only the Python automation script should be able to decrypt this to send the email. This prevents database admins from snooping on who the beneficiaries are.



4.4 Integrity Check (HMAC Binding):



4.4.1 The Problem: Preventing a malicious Admin from swapping a beneficiary's email in the database to their own email to steal the data.



4.4.2 The Solution: When the user saves an item, the App must generate a "Signature" of the (EncryptedData + RecipientEmail) using a hidden, device-generated key (stored in secure storage).



4.4.3 The Verification: The Python script checks this Signature before sending. If the Admin changed the email in the database, the Signature will not match.



4.4.4 The Consequence: If a mismatch is detected, the script must DELETE the data immediately (Safety Protocol). Do not send the compromised data.



4.5 Anti-Hack Policies: Use Supabase Row Level Security (RLS). The database must reject file uploads if the user does not have a valid "Pro" or "Lifetime" status.



---



## 5. Pricing Plans & Features



---



5.1 Free Plan:



5.1.1 Limit: Max 3 Text Items.



5.1.2 Mode: "Send" Mode Only (Standard Legacy).



5.1.3 Timer: Fixed at 30 Days. (User cannot change this).



5.1.4 Warning System: Relies on Push Notifications ONLY. No email warnings.



5.2 Pro Monthly ($1.99/mo) or Annual ($19.99/yr):



5.2.1 Limit: Unlimited Text Items.



5.2.2 Feature: "Protocol Zero" (Destruction Mode). This allows the user to set items to Delete instead of Send here email is not required as data will get deleted after the duration chose if user stays inactive.



5.2.3 Feature: Custom Timers. User can unlock the timer settings and adjust their check-in frequency from 7 days up to 365 days (1 Year).



5.2.4 Warning System: Local Push + Server-Side Email Warning. This is the "Fail-Safe" for paid users.



5.3 Lifetime Access ($99.99 One-Time):



5.3.1 Includes ALL Pro features (Unlimited Text, Destruction Mode, Custom Timers up to 10 years).



5.3.1.1 Timer Range: 7 Days to 3650 Days (10 Years).



5.3.1.2 Use Case: "Time Capsule" for children/legacy.



5.3.1.3 The "Tragedy" Warning: IF a user selects a duration > 365 Days, show a UI Warning: "‚ö†Ô∏è NOTE: This is a Time Capsule setting. Beneficiaries will NOT receive this until the full duration passes, even if you stop checking in tomorrow."



5.3.2 Feature: Audio Vault.



5.3.3 Audio Limit: To prevent storage abuse, Lifetime users have a "Time Bank" of 10 Minutes Total. They can record multiple files, but the total duration cannot exceed 10 minutes. If the limit is reached, disable the record button.



---

## 6. Notification Strategy (Hybrid Model)





6.1 To save costs, we rely on the phone's internal clock for most warnings, but provide a premium email backup for paid users.



6.2 Push notifications for free users (30 Days), no emails here, only push notifications (For Everyone): Free Tier (The "Risky" Tier)

Yellow Warning: Push Notification only. ("Hey, open the app!") 



Red Warning: Push Notification only



No email alert here



Expiry Action: Email sent to Beneficiary.



Rule Set.



Push #1 ‚Üí at 66% of remaining time (Yellow Warning)

Push #2 ‚Üí at 33% of remaining time (Red Warning)



that's it, no more warnings



6.3 Paid users: Server Email (Paid Only- Pro and lifetime users): Here we send a push notification two times at the end month, If the user ignores all alerts, the Python Script sends a "Final Warning" a day before timer expires ONLY if the user is on a Paid Plan. The email is sent to user on same email they used during google auth sign in



Rule set for it:



For PAID users only:



Push #1 ‚Üí at 66% of remaining time (Yellow Warning)

Push #2 ‚Üí at 33% of remaining time (Red Warning)

Final Email ‚Üí 24 hours before expiry, ONLY IF:



both pushes were ignored

user is still on paid plan



No special cases here, like unlike in free tier, here user can choose custom time of 7 days or 777 days, just follow the rule set above, same math.



6.4: We only send notifications or email to users only if something exists in the vault, CRITICAL CHECK: Script asks database: "Does this user have any rows in the vault_items table?" be it audio or text or any data



Answer: NO.



Action: Script SKIPS him. No email. No notification. He is ignored.



IF answer is yes, do the notifications as stated above.



---



## 7. Automation Logic (The Python Script)



---



7.1 The script runs every 24 hours via GitHub Actions. It follows this exact logic:



7.2 Pass 1: The Warning 



7.2.1 Check: Is the user due for a check-in within 24 hours?



7.2.2 Filter: Is the user on a Paid Plan (Pro/Lifetime)? AND Is their Vault Not Empty?



7.2.3 Action: If yes, decrypt their email and send the "Final Warning." If they are Free or Empty, do nothing.



7.3 Pass 2: The Execution (Day 30+ or in case of custom timing, after the time is up)



7.3.1 Check: Has the user timer expired? AND Is the Vault Not Empty?



7.3.2 If Action is "Send": Verify the HMAC Signature. If valid, decrypt the Recipient Email and send the message via Resend. The message includes the Link to the Web Viewer and the Decryption Key. Update the item status to `SENT`.



7.3.3 If Action is "Destroy": Immediately DELETE the row from the database. Do not send any email. The data simply vanishes.



7.4 Pass 3: The Cleanup (Day 31 Post-Send or in case of custom timer a day after the post send)



7.4.1 Check: Find items marked `SENT` that are older than 30 days. Here I mean no matter what, if items were sent, like timer expired, no matter if paid or free users- if 30 days are done since item is sent, we delete their data forever because its sent and we don't store sent data after 30 days are over.

We store their data only for 30 days after sent, delete on day 31



7.4.2 Action: Hard Delete these rows and files permanently.



---



## 8. User Return Scenarios (The "Lazarus" Logic)



---



8.1 What happens if a user returns to the app after the timer expired?



8.2 Case 1: User returns during the 30-Day Grace Period (Data was Sent)



8.2.1 The user logs in. Show a "History" tab with the items marked as `SENT`.



8.2.2 Make these items Read-Only. The user can View them or Delete them, but cannot Edit them (since they were already emailed).



8.2.3 Allow the user to click the "Pulse" ring to reset the timer and start creating new items.



8.3 Case 2: User returns after Day 31 (Data is Deleted)



8.3.1 The user logs in. The Vault is empty.



8.3.2 Show a log entry: "Protocol Executed on [Date]. Data permanently erased."



8.3.3 The User Account is still active. They do not need to sign up again. They simply reset the timer and start fresh with a new vault.



---



## 9. The Web Viewer (Vercel)



---



9.1 This is a static HTML/JS page.



9.2 Function: It takes the Decryption Key (typed by the beneficiary), fetches the encrypted blob from Supabase, and uses Javascript to decrypt it inside the browser.



9.3 Download: Include a button allowing the beneficiary to download the decrypted Text (.txt) or Audio (.mp3) file to save the memory.



---



## 10. Beneficiary enters key from email on the site after 30 day grace period when data is permanently deleted



---



10.1 In case they still did not open after 30 days



10.2 This is a critical UX moment. You are dealing with someone who is grieving, late, and now realizes they missed the final message from a loved one.



10.3 If they see a generic "404 Not Found" or "Error," they will panic and think the app is broken. They might email you screaming.



10.4 You need a specific "Expired Page" that is compassionate but firm about the security.



10.5 1. What they should see (The Web Page)



10.5.1 Since you aren't building a full web app, this is just a simple HTML page (like your landing page).



10.5.2 Visual: Dark background (somber), minimal design.



10.5.3 Icon: A simple open lock üîì or a broken hourglass ‚åõ.



10.5.4 Headline: "Message Unavailable" (Don't say "Deleted" immediately, it sounds harsh).



10.6 The Text Copy (Copy-Paste this):



This secure transmission has expired.

You are trying to access a secured message from [Sender Name].

To protect the sender's privacy and security, all data in this vault was configured to permanently self-destruct 30 days after delivery.

That time window has passed. In accordance with our Zero-Knowledge security protocols, the encryption keys have been shattered and the data has been permanently erased from our servers. It cannot be recovered by anyone, including our support team.



------------------------------------------------------------------------------------------------------------------



# Important Things:



---



## 1. How to handle "Multiple Vaults" & Editing



---



1.1 Don't overcomplicate it. You don't want "Multiple Timers" (that is confusing). I want One Timer Per user (The Heartbeat) that controls Multiple Boxes.



1.2 The Architecture:



1.2.1 The User (Master Lock): The user has one check-in timer (e.g., "SOUL FIRE").



1.2.2 The Items (The Boxes): Inside the app, the user sees a list. They can add as many "Items" as they want.



1.2.3 Item 1: Text Note ("Crypto Keys") -> Set to: Destroy.



1.2.4 Item 2: Audio ("For Wife") -> Set to: Send to Wife.



1.2.5 Item 3: Text Note ("Secret recipe") -> Set to: Send to Brother.



## 2. How "Edit/Delete" works with Encryption



---



2.1 Since everything is encrypted, you can't just "edit a word."



2.2 Unlock: User clicks the item. App decrypts it locally so they can see it.



2.3 Edit: User types new text.



2.4 Save: The App re-encrypts the whole thing (generating a new random noise blob) and overwrites the old row in Supabase.



2.5 Delete: Simple. The App tells Supabase DELETE FROM vault_entries WHERE id = XYZ. It is gone forever.



## 3. Preventing "Mods" (Anti-Tamper Strategy)



---



3.1 Worried someone will download your APK, modify it to bypass the "Payment" screen, or try to steal data.



3.2 The Truth: You cannot 100% prevent someone from modifying the APK (e.g., WhatsApp mods exist). BUT, you can make it useless for them.



3.3 Rule 1: Logic on Server (The Golden Rule).



3.3.1 Never put logic like if (user_paid) { unlock_audio } solely in the app code.



3.3.2 Instead, use Row Level Security (RLS) in Supabase.



3.3.3 Policy: "Only allow INSERT into audio_table if user.subscription_status = 'premium'."



3.3.4 If a modded app tries to upload audio for a free user, Supabase will reject it with a 403 Forbidden error. The server is the gatekeeper.



3.4 Rule 2: Flutter Obfuscation.



3.4.1 When you build the app for release, use the --obfuscate flag. It turns your readable code into unreadable gibberish (symbols), making it very hard for hackers to reverse-engineer.



3.4.2 Command: flutter build apk --obfuscate --split-debug-info=/<project-name>/<directory>



## 4. The Timer tracks YOU, not the files



---



4.1 Think of it like a building with a security guard.



4.1.1 The Timer is the Guard.



4.1.2 The Files (Texts/Audios) are the boxes in the secure room.



4.1.3 The Creation Date doesn't matter.



## How it works in practice:



---



H.1 1. Day 1: You sign up and set your timer to 30 Days. You add a text note ("Bank Password").



H.2   System says: "Okay, if I don't see Tejasvi by Day 31, I unlock everything."



H.3 2. Day 15: You open the app to add a new note ("Love letter").



H.4   The Magic: Just by opening the app, the Timer resets.



H.5   System says: "Oh, Tejasvi is here! He is alive. I am resetting the countdown. Now everything is safe until Day 45 (Day 15 + 30)."



## So, does it matter if I create them days apart?



---



S.1 No.



S.2 Every time you open the app to add, edit, or just look at your vault, you are telling the system "I am still here." This protects ALL your items instantly.



S.3 It doesn't matter if you wrote a note 2 years ago or 2 minutes ago. As long as you checked in recently, the guard keeps the door locked.



---



The Python script only looks at the User Table. If Tejasvi is "Late," it executes the action for Item 1, 2, and 3 all at once.



Same logic in case of custom timer for paid users or free, no matter.



## 5. Can users add multiple beneficiary emails?



---



5.1 Yes. The best way to do this is "Per Item" rather than "Per Profile."



5.2 Instead of having just one "Main Beneficiary" for the whole account, allow the user to define the recipient for each specific secret.



5.3 Item 1 (Bank Passwords): Send to [wife@example.com](mailto:wife@example.com)



5.4 Item 2 (Crypto Keys): Send to [brother@gmail.com](mailto:brother@gmail.com)



5.5 Item 3 (Confession): Send to [bestfriend@yahoo.com](mailto:bestfriend@yahoo.com)



---



## 6: NO email is needed in case users choose destruction after xyz time (paid users)





6.1 #### 6: NO email is needed in case users choose destruction after xyz time (paid users)



---



## 7: The timer starts as soon as the Gmail account is made (Sign Up).



---



7.1 ‚Ä¢ Here is why, and how it handles "Empty Vaults":



7.2 ‚Ä¢ 1. The Technical Reason (Simplicity)



7.3 ‚Ä¢ When a user signs in with Google, your app creates a row in the profiles database table.



7.4 ‚Ä¢ That row has a column: last_check_in.



7.5 ‚Ä¢ By default, this is set to NOW() (the moment of sign-up).



7.6 ‚Ä¢ Therefore, the countdown starts immediately from Day 1.



7.7 ‚Ä¢ 2. The "Empty Vault" Scenario



7.8 ‚Ä¢ You might be wondering: "What if they sign up, add nothing, and then forget the app? Will it send a blank email to no one?"



7.9 ‚Ä¢ No. Your Python script handles this automatically with the logic we defined:



7.10 ‚Ä¢ The Timer runs out (User is "Late").



7.11 ‚Ä¢ The Script looks for Vault Items.



7.12 ‚Ä¢ If Vault is Empty: The script finds 0 items to send. It simply marks the user as "Inactive" and does nothing. No emails are sent. No one is bothered.



---



## 8: 1. "Even if note is deleted, it doesn't affect the timer?"



8.1 ‚Ä¢ Correct. The timer watches YOU, not your notes.



8.2 ‚Ä¢ You can add 50 notes and delete all of them. The timer keeps ticking based on when you last logged in. It doesn't care if the vault is full or empty.



8.3 ‚Ä¢ 2. "If they delete everything, script sends nothing?"



8.4 ‚Ä¢ Correct. This prevents the "Empty Email" embarrassment.



8.5 ‚Ä¢ Scenario: You set a timer. You add a note. You get angry and delete the note. You disappear.



8.6 ‚Ä¢ Result: The timer runs out. The script wakes up. It looks inside your vault and sees 0 Items. It shuts down without sending a single email.



8.7 ‚Ä¢ 3. "If they make a note on Day 29, does the timer restart?"



8.8 ‚Ä¢ Correct. This is the core "Check-in" mechanic.



8.9 ‚Ä¢ Day 1: Timer starts (30 Days left or whatever the duration it is).



8.10 ‚Ä¢ Day 29: You open the app to write a new note.



8.11 ‚Ä¢ The Magic: As soon as the app opens, it updates your last_check_in to Now.



8.12 ‚Ä¢ Result: Your new deadline is 30 Days from today. You are safe until Day 59. Same logic in case of custom timer.



---



## 9: This is the final set of "Edge Case" questions that define the difference between a buggy app and a professional platform.



---



9.1 ‚Ä¢ Here is exactly how we handle the Decryption Key, Editing, Post-Death Cleanup, and the "False Alarm" scenario.



### 9.2 1. The "Trust" Problem: Can I (the Admin) unlock their data?



9.2.1 ‚Ä¢ The Hard Truth: If your Python script needs to email the key to the beneficiary, then your system must technically have access to that key.



9.2.2 ‚Ä¢  "What if I unlock it?" Yes, technically, if you are a malicious admin with full database access and the encryption keys, you could.



9.2.3 ‚Ä¢  How to protect yourself (and the user): You implement "Encryption at Rest" for the Key itself.



9.2.4 ‚Ä¢  The Setup: The User's device generates a random Data Key. This key encrypts their secret.



9.2.5 ‚Ä¢  The Storage: You do not store the Data Key plainly in Supabase. You encrypt the Key itself using a Master Server Secret (which you hide in GitHub Secrets, not the database).



9.2.6 ‚Ä¢  The Result: If you look at your Supabase database, you see:



9.2.6.1 ‚Ä¢  `Secret_Message`: `ksjdf8723kjsd...` (Gibberish)



9.2.6.2 ‚Ä¢  `Decryption_Key`: `98234lkjfsd...` (Gibberish)



9.2.7 ‚Ä¢  The Safety: You cannot read it just by looking at the table. The only thing that can read it is the Python Script during the official execution process. This prevents "accidental" snooping.



### 9.3 2. What if the user Edits or Deletes?



9.3.1 ‚Ä¢ This is standard "CRUD" (Create, Read, Update, Delete) logic, but with security rules.



9.3.2 ‚Ä¢ User Edits Text: The App decrypts the old text -> User types new text -> App re-encrypts it -> Overwrites the row in Supabase.



9.3.3 ‚Ä¢ User Edits Email: Simple update to the `recipient_email` column.



9.3.4 ‚Ä¢ User Deletes Item:



9.3.4.1 ‚Ä¢ Text: Instantly `DELETE` the row. It is gone forever.



9.3.4.2 ‚Ä¢ Audio: Instantly `DELETE` the file from Storage bucket AND the row from the database.



9.3.5 ‚Ä¢ Safety: You don't keep backups of deleted user data. Once they delete, it must be truly gone.



### 9.4 3. The "Death" Lifecycle: What happens after the email sends?



9.4.1 ‚Ä¢ We need a clean "Cleanup Protocol" so you aren't storing dead people's data forever (and paying for it).



9.4.2 ‚Ä¢ The Timeline:



9.4.2.1 ‚Ä¢ 1. Day 0 (Deadline): Script runs. Detects user is late.



9.4.2.2 ‚Ä¢ 2. Action: Sends the Email with the Key + Link.



9.4.2.3 ‚Ä¢ 3. Immediate Step: The script updates the item status from `Active` to `Sent` (or `Released`).



9.4.2.4 ‚Ä¢ 4. Day 30 (The Grace Period): We keep the data for 30 Days just in case the email went to Spam and the beneficiary needs us to resend it.



9.4.2.5 ‚Ä¢ 5. Day 31 (The Purge): The script runs a "Cleanup" job. It finds all items marked `Sent` > 30 days ago.



9.4.2.5.1 ‚Ä¢  It permanently deletes the encrypted text/audio files.



9.4.2.5.2 ‚Ä¢  It keeps the User Profile (row) but marks it as `Archived`.



9.4.2.5.3 ‚Ä¢  Why keep the profile? So if the user (who might not be dead, just in a coma) wakes up 6 months later, they can log in and see: "Status: Account Archived. Messages Sent on Jan 22."



### 9.5 4. The "False Alarm" (The User comes back alive)



9.5.1 ‚Ä¢ Suppose the user was just stranded on an island, missed the deadline, and the emails were sent.



9.5.2 ‚Ä¢ Scenario: Emails sent on Monday. User logs in on Wednesday.



9.5.3 ‚Ä¢ Login: They CAN still log in. We never delete their account/login ability, only the Vault Data.



9.5.4 ‚Ä¢ The View: They see an empty vault (or a log saying "Sent to Wife").



9.5.5 ‚Ä¢ The Reset:



9.5.5.1 ‚Ä¢ They click "SOUL FIRE"



9.5.5.2 ‚Ä¢ The system sets their status back to `Active`.



9.5.5.3 ‚Ä¢ The Timer resets.



9.5.5.4 ‚Ä¢ They can create new notes.



9.5.6 ‚Ä¢ Note: The old notes are gone (sent/scheduled for delete). They cannot "un-send" the email, but they can secure their account for the future.



9.5.7 ‚Ä¢ Grace period applies ONLY to SEND.



9.5.8 ‚Ä¢ DESTROY = instant deletion. No grace. No mercy.



---



## Final Updated Logic



---



9.6 ‚Ä¢ 6. Security & Cleanup Protocols (CRITICAL)



9.6.1 ‚Ä¢  Key Storage (The "Blind Admin" Rule):



9.6.1.1 ‚Ä¢  The `decryption_key` for each vault item must be stored in the database Encrypted, using a `SERVER_SECRET` (AES) that is stored ONLY in GitHub Secrets and the Flutter App Build Env. It must NOT be visible as plain text in the Supabase Table.



9.6.1.2 ‚Ä¢ Goal: I (the admin) should see only gibberish in the database. Only the App (for the user) and the Script (for the beneficiary) can unlock it.



9.6.2 ‚Ä¢ If the data is still on the server (Day 1-30), the user SHOULD be able to see it.



### 9.7 The Correct "Lazarus" Logic (User Comes Back Alive)



9.7.1 ‚Ä¢ If the user logs in after the email was sent (Monday) but before the 30-day deletion (Next Monday):



9.7.1.1 ‚Ä¢ 1. Login: They log in successfully.



9.7.1.2 ‚Ä¢ 2. The Dashboard: They see a big Red Alert: "Protocol Executed on Monday. Emails have been sent."



9.7.1.3 ‚Ä¢ 3. The Data:



9.7.1.3.1 ‚Ä¢  Old Logic (Wrong): Vault is empty.



9.7.1.3.2 ‚Ä¢  New Logic (Correct): They see their items marked as "SENT / ARCHIVED".



9.7.1.3.3 ‚Ä¢  Can they edit? No. (It‚Äôs already emailed; editing now changes nothing for the recipient).



9.7.1.3.4 ‚Ä¢  Can they view? Yes. (It‚Äôs still on the server).



9.7.1.3.5 ‚Ä¢  Can they delete? Yes. (If they want to scrub it immediately before the 30-day auto-purge).



9.7.2 ‚Ä¢ 6. Security & Cleanup Protocols (CORRECTED)



9.7.2.1 ‚Ä¢  Post-Send Retention (30-Day Wipe):



9.7.2.1.1 ‚Ä¢  When the script sends the data to the beneficiary, change the Vault Item status from `ACTIVE` to `SENT`.



9.7.2.1.2 ‚Ä¢  Do not delete immediately. Keep the encrypted data for 30 Days.



9.7.2.1.3 ‚Ä¢  Auto-Deletion Job: Create a scheduled job that runs daily: `DELETE FROM vault_entries WHERE status = 'SENT' AND sent_at < (NOW() - 30 DAYS)`.



9.7.2.2 ‚Ä¢  The "Lazarus" Scenario (User Returns Early):



9.7.2.2.1 ‚Ä¢  If a user logs in during the 30-day retention period:



9.7.2.2.1.1 ‚Ä¢  Do NOT show an empty vault.



9.7.2.2.1.2 ‚Ä¢  Show the `SENT` items in a "History" or "Archive" section.



9.7.2.2.1.3 ‚Ä¢  Restriction: Make these items Read-Only (since they were already emailed). The user can view them or delete them, but cannot edit them.



9.7.2.2.1.4 ‚Ä¢  Reset: Allow the user to click "SOUL FIRE" to reset their timer and start creating new `ACTIVE` items for the future.



9.7.3 ‚Ä¢ Now the logic holds up:



9.7.3.1 ‚Ä¢  Monday: Sent.



9.7.3.2 ‚Ä¢  Wednesday: User logs in -> Sees "Sent" items (Read Only).



9.7.3.3 ‚Ä¢  Next Monday: Data is deleted forever -> Vault History shows "Expired/Deleted."



---



## 10: The Data (Vault Items): Ephemeral. If the timer dies, the data dies (after 30 days).



---



10.1 ‚Ä¢ The User (Account): Permanent. Their login, their name, and their "Active/Inactive" status stays in your database forever (unless they manually choose "Delete Account").



---



## 11: keep an option for user to choose to permanently delete account which wipes all data



---



11.1 ‚Ä¢ keep an option for user to choose to permanently delete account which wipes all data



---



## 12: The "Day 31+" Scenario (After Permanent Deletion)



---



12.1 ‚Ä¢ Scenario: The user was gone for 80 days. The email was sent. The 30-day grace period passed. The data was scrubbed. The user logs in on Day 85.



12.2 ‚Ä¢ Can they create new stuff? YES.



12.3 ‚Ä¢ Do we delete their account? NO. Never delete the account (the profiles row).



12.4 ‚Ä¢ What do they see?



12.5 ‚Ä¢ They see a Clean Slate.



12.6 ‚Ä¢ Ideally, show a "History Log" or "Activity" tab that says: "Protocol Executed on [Date]. Data permanently erased."



12.7 ‚Ä¢ They click "Reset Timer" and start over from scratch with a fresh vault.



12.8 ‚Ä¢ This is critical because it retains your user base. Even if they "died" (digitally), they can be "reborn" as a customer without signing up again.



---



## 13: ONLY send email warning before data is sent or deleted to paid users but in case vault is empty, there is no point, only send even if one data exists



---



13.1 ‚Ä¢ ONLY send email warning before data is sent or deleted to paid users but in case vault is empty, there is no point, only send even if one data exists



---



## 14: 1. "Destroy" Action (Protocol Zero)



---



14.1 ‚Ä¢ "If we delete rows immediately, doesn't it delete data?"



14.2 ‚Ä¢ YES. That is the point.



14.3 ‚Ä¢ Who uses this? Journalists, activists, or people with secrets they never want anyone to see (e.g., private chats, incriminating documents).



14.4 ‚Ä¢ The Goal: If they get arrested or die, they want this data to vanish from the face of the earth.



14.5 ‚Ä¢ The Outcome: The script deletes the row. No email is sent. The data is gone forever. Beneficiaries get nothing.



14.6 ‚Ä¢ 2. "Send" Action (Legacy Mode)



14.7 ‚Ä¢ "And how will we send beneficiary all data?"



14.8 ‚Ä¢ This is the opposite of Destroy.



14.9 ‚Ä¢ The Outcome: The script DOES NOT delete the data immediately.



14.10 ‚Ä¢ The Step: It changes the status to SENT.



14.11 ‚Ä¢ The Email: It sends the Encryption Key and a Link to the beneficiary.



14.12 ‚Ä¢ The Deletion: It waits 30 Days, then deletes the data.



14.13 ‚Ä¢ 3. The Vercel Site (The "Magic Decoder")



14.14 ‚Ä¢ "How will the Vercel site be like?"



14.15 ‚Ä¢ You cannot just email the beneficiary the data directly because it is encrypted.



14.16 ‚Ä¢ If you email them the text, it looks like this: U2FsdGVkX1+98234...



14.17 ‚Ä¢ Your grandma/wife cannot read that.



14.18 ‚Ä¢ The Solution: The Vercel Website is a Secure Viewer.



14.19 ‚Ä¢ What the Beneficiary Sees (The User Flow):



14.20 ‚Ä¢ The Email:



14.21 ‚Ä¢ "Tejasvi has left you a secure message. To view it, click the link below and enter this Security Key: BLUE-HORSE-99" [ OPEN VAULT ] (Button)



14.22 ‚Ä¢ The Website (Vercel):



14.23 ‚Ä¢ They click the link. It opens view.afterword-app.com.



14.24 ‚Ä¢ The Look: Very clean. Black background. A white box in the center.



14.25 ‚Ä¢ The Prompt: "Please enter the Security Key from your email."



14.26 ‚Ä¢ The Magic (Decryption):



14.27 ‚Ä¢ They type BLUE-HORSE-99.



14.28 ‚Ä¢ They hit "Unlock."



14.29 ‚Ä¢ Crucial Tech Part: The website takes the Encrypted Data from your server, mixes it with the Key they just typed, and decrypts it right there in their browser.



14.30 ‚Ä¢ The Reveal: The gibberish turns into: "Hey honey, the bank account password is..." or plays the Audio file.



---



## 15: Can the Admin (You) see the Beneficiary Email?



---



15.1 ‚Ä¢ "Else I'll just edit emails to mine"



15.2 ‚Ä¢ The Risk: You are right. If the database shows recipient_email: [wife@gmail.com](mailto:wife@gmail.com) in plain text, a corrupt employee (or you) could change it to [me@hacker.com](mailto:me@hacker.com), wait for the timer, and steal the key.



15.3 ‚Ä¢ The Fix: Encrypt the Metadata (The "Blind Courier" System). We will instruct the developer to Encrypt the Email Address before saving it to the database.



15.4 ‚Ä¢ How it works:



15.4.1 ‚Ä¢ App: User types [wife@gmail.com](mailto:wife@gmail.com). App encrypts it -> U2FsdGVkX1... -> Saves to DB.



15.4.2 ‚Ä¢ Database: You (looking at the dashboard) only see gibberish. You cannot edit it because you don't know the encryption format.



15.4.3 ‚Ä¢ The Script: The Python script has a special "Master Key" (hidden in GitHub Secrets). It decrypts the email only for the split second it needs to send the message via Resend.



15.4.4 ‚Ä¢ Result: You cannot see who the recipient is, and you cannot edit it to your own email without breaking the encryption.



15.5 ‚Ä¢ 2. Is the Audio Encrypted?



15.5.1 ‚Ä¢ Yes. It is white noise.



15.5.2 ‚Ä¢ The Process:



15.5.2.1 ‚Ä¢ Record: The app records the voice note (e.g., .m4a).



15.5.2.2 ‚Ä¢ Scramble: Before uploading, the app takes the file's "bytes" and scrambles them using AES encryption.



15.5.2.3 ‚Ä¢ Upload: The file uploaded to Supabase is basically a block of static noise.



15.5.3 ‚Ä¢ The Protection: If you (Admin) download the file and try to play it in VLC Player, it will say "File Corrupted / Error." It is unplayable without the key.



15.6 ‚Ä¢ 3. Can the Beneficiary Download?



15.6.1 ‚Ä¢ Yes. On the Vercel "Web Viewer," once the Javascript decrypts the data, we will generate a temporary Download Button.



15.6.1.1 ‚Ä¢ Text: "Download as .txt"



15.6.1.2 ‚Ä¢ Audio: "Download as .mp3"



---



## 16: he Vulnerability: You are 100% correct. If you (the Admin) have access to the database, you could technically:



---



16.1 ‚Ä¢ Go to the vault_entries table.



16.2 ‚Ä¢ Find a row with recipient_email (Encrypted).



16.3 ‚Ä¢ Delete that string and paste your own encrypted email string.



16.4 ‚Ä¢ Wait for the script to run.



16.5 ‚Ä¢ The script sends the "Key" and "Data Link" to YOU instead of the wife.



16.6 ‚Ä¢ The Fix: "Cryptographic Binding" (The Wax Seal) We prevent this by making the Data and the Email inseparable. We use a technique called HMAC (Hash-Based Message Authentication Code).



16.7 ‚Ä¢ How "Binding" Stops You (The Admin)



16.7.1 ‚Ä¢ When the User's App (Flutter) saves an item, it does a special math calculation on the phone:



16.7.1.1 ‚Ä¢ The Formula: It takes the Encrypted_Data + Recipient_Email and mixes them together using the User's Password (which you don't have).



16.7.1.2 ‚Ä¢ Signature = Hash(Data + Email + User_Secret)



16.7.1.3 ‚Ä¢ The Storage: It saves this Signature in the database row.



16.7.2 ‚Ä¢ The Check (Your Script): When your Python script tries to send the email, it runs the same math:



16.7.2.1 ‚Ä¢ It looks at the Email in the DB.



16.7.2.2 ‚Ä¢ It looks at the Data in the DB.



16.7.2.3 ‚Ä¢ It calculates the Signature.



16.7.3 ‚Ä¢ The Trap: If YOU changed the Email in the database, the Signature will not match.



16.7.4 ‚Ä¢ The Result: The script sees the mismatch, logs "TAMPERING DETECTED," and refuses to send the email.



16.8 ‚Ä¢ Conclusion: You can destroy the data (by messing with the table), but you cannot steal it (redirect it), because you cannot generate a valid Signature for your new email address without the user's password.



---



## 17: Restricting the "Warning Email" to Paid Users does two things:



---



17.1 ‚Ä¢ Reduces your costs to almost $0. (Free users cost you literally nothing now).



17.2 ‚Ä¢ Creates a powerful upsell. "Don't trust your phone notifications? Get the Email Fail-Safe for $1.99."



17.3 ‚Ä¢ Here are the answers to your questions and the final polish for the developer.



17.4 ‚Ä¢ 1. Can I keep the Email Reminder for Paid Users only?



17.4.1 ‚Ä¢ Yes.



17.4.2 ‚Ä¢ Free Users: Rely 100% on push Notifications. If their battery dies or they ignore the notification, the protocol executes. It is "High Risk, Free Reward."



17.4.3 ‚Ä¢ Paid Users (Pro/Lifetime): Get the Server-Side Email Warning. This is the "Insurance Policy." Even if their phone is lost in a river, they get the email on their laptop.



---



18. "SOUL FIRE" button implementation 



Reference Style: Blue Ethereal Smoke/Plasma.



1. COLOR PALETTE:

   - Core Brightness (Center): #CDFCFF (Ice White)

   - Inner Glow: #00E5FF (Cyan/Electric Blue)

   - Outer Smoke: #0077BE (Ocean Blue)

   - Deep Shadows: #020B14 (Deep Void Blue/Black)

   - Background: #000000 (Pure OLED Black)



2. THE COMPONENT LAYOUT:

   Instead of a flat button, we are building a "Portal" effect using a Stack.

   

   Layer 1 (Bottom): The "Void" (Black background).

   Layer 2 (Middle): The "Smoke" (Animated textures rotating slowly).

   Layer 3 (Top): The "Core" (The interactive touch area).



3. ANIMATION STATES:



   A. STATE: IDLE (Breathing)

      - Visual: Faint blue wisps of smoke swirling at the bottom center of the screen.

      - Opacity: Low (30%).

      - Animation: Slow, vertical drifting (like dry ice or slow fire).

      - Core: A small, pulsing dot of #00E5FF in the center.



   B. STATE: HOLDING (Charging)

      - Visual: The smoke intensifies.

      - Action: As user holds, the blue light "grows" upward, filling the screen height.

      - Color Shift: The center turns from Blue to White (#CDFCFF).

      - Physics: The swirl speed increases (Turbulence).

      - Haptic: Ramping vibration (Light -> Heavy).



   C. STATE: RELEASE (Success)

      - Visual: "Ignition."

      - Effect: A sudden flash of white light that washes over the screen (like a camera flash or lightning), then fades back to black.

      - Text Reveal: "CHECK-IN COMPLETE" fades in (Gold or White text).



4. FLUTTER IMPLEMENTATION TIPS (For the Dev):

   - BLENDING: Crucial! Use `BlendMode.screen` or `BlendMode.plus` (Additive Blending) for the smoke layers. This makes them "glow" against the black background.

   - ASSETS: Use 2-3 transparent PNGs of "smoke wisps." Rotate them in opposite directions to create the "plasma" effect. 

   - PACKAGE: Consider `simple_animations` for the particle drift or `shader_buffers` if you want to get fancy with GLSL.



FINAL ASSETS FOR "SOUL FIRE" BUTTON



Here are the 3 updated assets. They are much higher quality. In this folder: "D:\Afterword\IMPORTANT\soul-fire"



1. smoke_texture.png (The vertical wisps)

2. core_glow.png (The center heat)

3. particles.png (The rising embers)



IMPLEMENTATION REMINDER:

- Please use `BlendMode.plus` or `BlendMode.screen` for ALL layers.

- Tint them Cyan/Electric Blue (Color(0xFF00E5FF)).

- Rotate the smoke layers slowly in opposite directions.

- Animate the particles rising upward.



CRITICAL IMPLEMENTATION DETAILS:



1. THE TECHNIQUE:

   - Do NOT just display these images normally.

   - You must use a Stack with BlendModes to make them "glow" against the black background.

   - Use `BlendMode.plus` (Additive) or `BlendMode.screen`.



2. THE COLORING (How to make it blue):

   - Since these assets are grayscale (white on transparent), use the `color` and `colorBlendMode` properties of the Flutter Image widget to tint them.

   - TINT COLOR: Use Cyan/Electric Blue (e.g., `Color(0xFF00E5FF)`).



3. THE ANIMATION LAYERS (Bottom to Top):

   - Layer 1 (Smoke): Place `smoke_texture.png`. Tint it dark blue. Rotate slowly clockwise. Lower opacity.

   - Layer 2 (Smoke): Place `smoke_texture.png` again. Tint it brighter cyan. Rotate counter-clockwise slightly faster.

   - Layer 3 (Particles): Place `particles.png`. Tint cyan. Animate them slowly moving upward.

   - Layer 4 (Core): Place `core_glow.png` at the bottom center. Tint it bright white/cyan. Pulse its scale slightly to make it "breathe."



---

App looks:



19. Splash screen should show only the logo on a completely black screen.



19.1 The CTA buttons should be in a left-side menu dropdown. It should display my profile with my name (taken from the email and editable), the email itself, and an avatar to use as a profile picture (do not use sql for profile picture, like just use offline emojis typa or anything, no database for this). This section should also contain other buttons such as account settings (to change name and add avatar or basically just delete account ) My Notes, Recipient List, Subscription, Privacy Policy, Terms & Conditions, How It Works, Add New Note, and Log Out, and any other important settings,



19.2 A ‚ÄúHow It Works‚Äù page that explains everything in extremely simple terms so even a toddler can understand it, including clear details about how secure the app is. Include everything that is visible in the screenshot.



10.3: On the main screen or what we call home page just include that "SOUL FIRE" along with like options to make a note (add new note) and all stuff



10.4: Rest you manage yourself and add all stuff that's needed, just make sure app looks the most beautiful and premium.



-----------------------------------------------------------------------------------------------------



## Finally This:



I asked an expert what could possibly go wrong with my app, here is the list.



So, make sure to keep my app safe.



# A ‚Üí Z: Everything that can go wrong (no fixes)



## A



* Admin abuse ‚Äî privileged person edits DB, changes recipient, reads metadata.

* API abuse ‚Äî unauthenticated or abused endpoints used to enumerate or dump data.

* Account takeover ‚Äî OAuth/credentials stolen, attacker controls account.

* Automation abuse ‚Äî attacker triggers or manipulates the python automation.

* Asymmetric key mismanagement ‚Äî private keys exposed or mixed up.

* Aging backups leakage ‚Äî old backups contain keys/plaintext.

* Ambiguous state transitions ‚Äî items stuck in limbo (PENDING/FAILED/etc).

* Availability outages ‚Äî services (Supabase/Resend/Vercel) down.



## B



* Backup resurrection ‚Äî deleted data returns from restores.

* Brute-force on web viewer ‚Äî guessing decryption keys or tokens.

* Broken idempotence ‚Äî repeated script runs cause duplication or lost state.

* Business-logic bugs ‚Äî wrong users get access from logic errors.

* Billing fraud ‚Äî payment/service abuse or chargebacks.

* Broken crypto libs ‚Äî vulnerable or outdated cryptography libs used.



## C



* Credential leakage ‚Äî secrets in logs, CI, or builds.

* Clock/timestamp attacks ‚Äî time tampering on device or server.

* Canonicalization mismatch ‚Äî HMACs fail due to different encoding.

* Cross-site scripting (XSS) on web viewer.

* Cross-origin (CORS) misconfig allowing data access.

* Corrupted uploads ‚Äî partial or malformed encrypted data stored.

* Concurrent edits causing inconsistent HMAC/versions.



## D



* Double-send ‚Äî email sent twice due to race or replay.

* Data-remnant in caches ‚Äî CDN, browser cache, or proxies keep copies.

* Deleted-but-backed-up ‚Äî ‚Äúdeleted‚Äù items present in snapshots.

* Destructive automation bug ‚Äî mass-delete due to bad filter.

* Disclosure via email headers ‚Äî sensitive metadata in message headers.

* Dependency compromise ‚Äî malicious npm/pip package in build.



## E



* Endpoint exposure ‚Äî admin or internal endpoints reachable publicly.

* Encryption misuse ‚Äî wrong mode/IV/nonce reuse or absent AEAD.

* Escrow/ownership ambiguity ‚Äî who legally controls keys/data.

* Email spoofing ‚Äî attackers forge emails to beneficiaries.

* Error logging leaks ‚Äî stack traces contain secrets.



## F



* Forked workflows / replayed CI ‚Äî attacker replays historical GitHub Actions.

* Failed rollbacks ‚Äî partial rollbacks leave system inconsistent.

* File orphaning ‚Äî storage objects without DB rows.

* Flooding / DoS ‚Äî create accounts/upload floods to exhaust resources.

* Forensic traces ‚Äî inadequate audit trail for incident review.



## G



* Git secrets leakage ‚Äî secrets committed to repo or PRs.

* Garbage collection gaps ‚Äî deleted objects persist in cold storage.

* Granularity mistakes ‚Äî overly broad DB privileges or policies.

* Geo-jurisdiction exposure ‚Äî storing data in wrong legal region.



## H



* HMAC key compromise ‚Äî attacker forges signatures or bypasses binding.

* Hijacked webhook ‚Äî attacker intercepts or fakes webhook calls.

* Human error ‚Äî support staff accidentally changes data.

* Hard-coded secrets in mobile builds or frontend bundles.



## I



* Idempotency failures ‚Äî non-repeat-safe operations produce double actions.

* Injection vulnerabilities ‚Äî SQL/command injection in inputs or scripts.

* Insider social engineering ‚Äî staff tricked into exposing access.

* Insecure temporary files on device/server containing plaintext.



## J



* Jurisdictional contradiction ‚Äî data laws conflict across regions.

* JWT misuse ‚Äî poorly validated tokens accepted, allowing impersonation.

* Job scheduling mistakes ‚Äî cron / GitHub Actions mis-timed or misconfigured.



## K



* Key rotation breakage ‚Äî rotated keys render stored data unreadable.

* KMS compromise ‚Äî KMS account hijacked exposing key material.

* Key leakage in CI logs ‚Äî secrets printed in build logs.



## L



* Leaked decryption keys in email ‚Äî keys sent in subject/body or URL.

* Liveness checks tampered ‚Äî attacker manipulates ‚ÄúSOUL FIRE‚Äù signal.

* Lack of monitoring ‚Äî automation fails silently with no alerts.

* Local-device compromise ‚Äî rooted/jailbroken phone exposing keys.



## M



* MitM during transport ‚Äî TLS misconfig allowing interception.

* Malformed ciphertext ‚Äî decryption fails unexpectedly and is unrecoverable.

* Metadata leakage ‚Äî filenames, sizes, counts reveal secrets.

* Missing consent/legal docs ‚Äî legal exposure for irrevocable deletes.



## N



* Nonce/IV reuse causing ciphertext compromises.

* Noisy telemetry leaks ‚Äî analytics reveal usage/patterns.

* Notification abuse ‚Äî spamming or notification content leaking state.

* Network partition leading to split-brain on status updates.



## O



* Orphaned DB rows referencing removed objects.

* Over-privileged service accounts used by automation.

* Operational blindspots ‚Äî no SLOs, no on-call, no runbooks.

* Open redirect on web viewer leading to phishing.



## P



* Phishing of beneficiaries imitating Afterword emails.

* Presigned URL errors ‚Äî long-lived or public URLs granting access.

* Permission misconfig in Supabase buckets exposing files.

* Payment system failure causing incorrect access changes.



## Q



* Quota exhaustion ‚Äî storage/email limits reached due to abuse.

* Quality/consistency drift ‚Äî test coverage misses edge cases.

* Query performance collapse ‚Äî script slow or times out on large data.



## R



* Replay attacks ‚Äî automation replay or message replay causes re-exec.

* Race conditions ‚Äî edit vs automation causes wrong payloads sent.

* Resend provider failure ‚Äî email provider outage without detect.

* RLS bypass ‚Äî Row-Level Security misconfigured allowing reads/writes.



## S



* Supply chain compromise ‚Äî malicious dependency in build chain.

* Script RCE potential ‚Äî unsafe deserialization or shell invocation.

* Side-channel leaks ‚Äî timing/padding/oracle attacks revealing plaintext.

* Socket/exposed DB ports accessible publicly.

* Snooping by cloud admins ‚Äî privileged cloud staff access.



## T



* Time calculation bugs ‚Äî off-by-one-day, DST, timezone errors.

* Tamper detection false positives ‚Äî canonicalization mismatch causing false alarms.

* Third-party data leak ‚Äî analytics or plugins leak PII.

* Token brute force ‚Äî insufficient token entropy or rate limits.



## U



* Unauthorized mass deletes ‚Äî accidental or malicious bulk deletions.

* Unencrypted metadata ‚Äî emails/recipient stored plaintext.

* Unvalidated inputs causing injection or malformed actions.

* Unrecoverable corruption ‚Äî bad writes permanently corrupting data.



## V



* Version skew ‚Äî app and script have incompatible crypto/version behavior.

* Vulnerability windows ‚Äî long delays between vulnerability discovery and patch.

* Visibility gaps ‚Äî no audit trail for specific destructive ops.

* Vendor lock-in failure modes ‚Äî provider outage impacting core flows.



## W



* Weak randomness ‚Äî predictable tokens or keys.

* Wrong side-effects ‚Äî send triggers deletion due to bad flag logic.

* Web viewer XSS/CSP bypass exposing decrypted content.

* Webhook replay or forged webhook executing unauthorized flows.



## X



* XML external entity (XXE) through any XML parsing in stack.

* X-Forwarded-For spoofing causing incorrect IP-based logic.

* XSS via beneficiary input (if any rich text allowed).



## Y



* Year/Date edge cases ‚Äî leap years, leap seconds causing expiry mismatch.

* Young users / minors storing sensitive material without guardian consent.

* Yielding to dependency failures ‚Äî system silently tolerates degraded crypto libs.



## Z



* Zero-day exploit in any dependency leading to mass compromise.

* Zombie processes replaying old automation actions after restore.

* Zone misconfiguration ‚Äî DNS mispointing exposing staging/prod.

* Zero-visibility admin actions ‚Äî no logging of who triggered destructive ops.



----------------------------------------------------------------------------------------



MAKE SURE ALL RISKS ARE WORKED UPON TOO:



Risk #1: Version skew (App vs Script)



If Flutter encrypts one way and Python decrypts slightly differently:



Boom ‚Üí permanent data loss



No recovery



Users rage



üî• Risk #2: Time bugs



DST. Timezones. Device clock lies.



You already did the right thing by:



Trusting server time for execution



Using device only for local reminders



But be strict:



last_check_in must be server-side timestamp



script must treat time as UTC-only



No exceptions.



üî• Risk #3: Web Viewer brute force



Humans choose trash keys unless you force entropy.



If someone can:



Guess keys



Hammer the viewer



Then encryption means nothing.



----------------------------------------------------------------------------------------------




## **1. Project Overview & Vibe**

‚Ä¢ **Target Platform:** **Android First**. (Build using Flutter for cross-platform potential, but optimize testing and release strictly for Android initially).

‚Ä¢ The app is a "Dead Man‚Äôs Switch" and "Digital Time Capsule." It addresses the core anxiety: *"What happens to my secrets if I die or disappear?"*

‚Ä¢ * **The Core Function:** Users set a "Check-in Timer" (Default: 30 Days). If they fail to open the app to reset the timer before it expires, the system automatically executes a pre-set protocol: either sending encrypted messages to specific beneficiaries or permanently destroying the data.

‚Ä¢ * **The Aesthetic:** The UI must be minimalist, cinematic, and high-trust. Use deep OLED blacks, warm ambers/golds, and clean, high-end sans-serif typography. It should feel like a secure Swiss bank vault or a flight recorder, not a social media app.

‚Ä¢ * **The Hero Interaction (The Pulse):** Instead of a standard button, the home screen features a "Breathing Ring" icon (a thin, abstract circle that slowly fades in and out).

‚Ä¢ * **Automatic Reset:** The timer MUST reset automatically in the background (`initState`) the moment the app is opened. The user is not required to touch anything.

‚Ä¢ * **Manual Reset:** The "Pulse" ring is there for psychological reassurance. If the user **Long Presses** the ring, it fills up visually, triggers a haptic vibration, and displays "Signal Verified." This confirms the timer has been reset.

---

## **2. The Tech Stack (Zero-Cost Architecture)**

‚Ä¢ We must strictly adhere to this stack to ensure the app costs $0 to run until we generate revenue.

‚Ä¢ **Mobile App:** Flutter (Dart). **Android First**.

‚Ä¢ **Backend & Auth:** Supabase (Free Tier). Use PostgreSQL for the database and Supabase Auth for users.

‚Ä¢ **Authentication Method:** Google Sign-In ONLY.

‚Ä¢ **Storage:** Supabase Storage (for Audio/Images).

‚Ä¢ **Automation (The Heartbeat):** GitHub Actions running a Python script. This runs once every 24 hours to check user timers.

‚Ä¢ **Email Service:** Resend API (Free Tier). To deliver the final "Unlock" emails.

‚Ä¢ **Web Viewer:** A simple HTML/JS page hosted on Vercel (Free). This allows beneficiaries to decrypt and view messages in their browser.

‚Ä¢ **Payments:** RevenueCat. To handle Subscriptions and Lifetime purchases.

‚Ä¢ **Notifications:** `flutter_local_notifications` (Primary) + Firebase Cloud Messaging (Secondary).

---

## **3. Core App Mechanics**

‚Ä¢ **The Master Timer:** Every user has one main countdown timer. It starts counting immediately upon account creation.

‚Ä¢ **Default Duration:** **30 Days** (Fixed for Free Users).

‚Ä¢ **User Identity:**

‚Ä¢ **Sender Name:** When signing up with Google, capture the default name but provide an **Editable Field** in Settings called "Sender Name." The user can change this to something recognizable like "Dad" or "Honey." This name is used in the Subject Line of final emails (e.g., "Message from Dad") to prevent them from looking like spam.

‚Ä¢ **Account Retention:** We never delete the User Profile (the account row in the database). We only delete the Vault Data. This allows users to return years later, log in via Google, and start fresh without re-registering.

‚Ä¢ **The Vault (One-to-Many Routing):**

‚Ä¢ Users can add multiple "Items" to their vault.

‚Ä¢ **Per-Item Logic:** Each item acts independently. The user must assign a specific Beneficiary Email for *each* item. (e.g., Bank Info sends to Wife; Confession sends to Brother).

‚Ä¢ **Validation:** If the Item Action is set to "Send," the user cannot save the item without entering a valid email address.

‚Ä¢ **Abuse Protection:** Rate limit creation to **max 1 item every 5 seconds** (client + server).

‚Ä¢ **Per-Letter Cap:** Silently cap each plaintext item at **50,000 characters** to prevent crashes (no UI counter).

---

## **4. Security Architecture (The Trust Layer)**

‚Ä¢ **App Lock:** Integrate `local_auth`. The app must require 6 digit PIN authentication immediately upon launch or resume.

‚Ä¢ **Client-Side Encryption (Zero Knowledge):** Use `flutter_sodium` or AES-256. All text and audio must be encrypted *on the device* before being uploaded. The server (and the Admin) must never see raw data.

‚Ä¢ **Encrypted Metadata:** The `recipient_email` column in the database must be encrypted. Only the Python automation script should be able to decrypt this to send the email. This prevents database admins from snooping on who the beneficiaries are.

‚Ä¢ **Integrity Check (HMAC Binding):**

‚Ä¢ *The Problem:* Preventing a malicious Admin from swapping a beneficiary's email in the database to their own email to steal the data.

‚Ä¢ *The Solution:* When the user saves an item, the App must generate a "Signature" of the `(EncryptedData + RecipientEmail)` using a hidden, device-generated key (stored in secure storage).

‚Ä¢ *The Verification:* The Python script checks this Signature before sending. If the Admin changed the email in the database, the Signature will not match.

‚Ä¢ *The Consequence:* If a mismatch is detected, the script must **DELETE the data immediately** (Safety Protocol). Do not send the compromised data.

‚Ä¢ **Anti-Hack Policies:** Use Supabase Row Level Security (RLS). The database must reject file uploads if the user does not have a valid "Pro" or "Lifetime" status.

---

## **5. Pricing Plans & Features**

‚Ä¢ **Free Plan:**

‚Ä¢ **Limit:** Max 3 Text Items.

‚Ä¢ **Mode:** "Send" Mode Only (Standard Legacy).

‚Ä¢ **Timer:** **Fixed at 30 Days.** (User cannot change this).

‚Ä¢ **Warning System:** Relies on **Local Push Notifications ONLY.** No email warnings.

‚Ä¢ **Pro Monthly ($1.99/mo) or Annual ($19.99/yr):**

‚Ä¢ **Limit:** Unlimited Text Items.

‚Ä¢ **Feature:** **"Protocol Zero" (Destruction Mode).** This allows the user to set items to *Delete* instead of *Send* here email is not required as data will get deleted after the duration chose if user stays inactive.

‚Ä¢ **Feature:** **Custom Timers.** User can unlock the timer settings and adjust their check-in frequency from 7 days **up to 365 days (1 Year)**.

‚Ä¢ **Warning System:** Local Push + **Server-Side Email Warning.** This is the "Fail-Safe" for paid users.

‚Ä¢ **Lifetime Access ($99.99 One-Time):**

‚Ä¢ Includes ALL Pro features (Unlimited Text, Destruction Mode, Custom Timers up to 1 year).

‚Ä¢ **Feature:** **Audio Vault.**

‚Ä¢ **Audio Limit:** To prevent storage abuse, Lifetime users have a "Time Bank" of **10 Minutes Total**. They can record multiple files, but the total duration cannot exceed 10 minutes. If the limit is reached, disable the record button.

---

## **6. Notification Strategy (Hybrid Model)**

‚Ä¢ To save costs, we rely on the phone's internal clock for most warnings, but provide a premium email backup for paid users.

‚Ä¢ **Local Notifications (For Everyone):** When the user checks in, the app cancels old alerts and schedules new local notifications for Day 10 ("Status: Secure"), Day 20 ("Reminder"), and Day 27 ("URGENT").

‚Ä¢ **Server Email (Paid Only):** If the user ignores all local alerts, the Python Script sends a "Final Warning" email on **Day 29**‚Äîbut ONLY if the user is on a Paid Plan. The email is sent to user on same email they used during google auth sign in

---

## **7. Automation Logic (The Python Script)**

‚Ä¢ The script runs every 24 hours via GitHub Actions. It follows this exact logic:

‚Ä¢ **Pass 1: The Warning (Day 29)**

‚Ä¢ Check: Is the user due for a check-in within 24 hours?

‚Ä¢ Filter: Is the user on a **Paid Plan** (Pro/Lifetime)? AND Is their Vault **Not Empty**?

‚Ä¢ *Action:* If yes, decrypt their email and send the "Final Warning." If they are Free or Empty, do nothing.

‚Ä¢ **Pass 2: The Execution (Day 30+)**

‚Ä¢ Check: Has the user timer expired? AND Is the Vault **Not Empty**?

‚Ä¢ *If Action is "Send":* Verify the HMAC Signature. If valid, decrypt the Recipient Email and send the message via Resend. The message includes the Link to the Web Viewer and the Decryption Key. Update the item status to `SENT`.

‚Ä¢ *If Action is "Destroy":* Immediately **DELETE** the row from the database. Do **not** send any email. The data simply vanishes.

‚Ä¢ **Pass 3: The Cleanup (Day 8 Post-Send)**

‚Ä¢ Check: Find items marked `SENT` that are older than 7 days.

‚Ä¢ *Action:* Hard Delete these rows and files permanently.

---

## **8. User Return Scenarios (The "Lazarus" Logic)**

‚Ä¢ What happens if a user returns to the app *after* the timer expired?

‚Ä¢ **Case 1: User returns during the 7-Day Grace Period (Data was Sent)**

‚Ä¢ The user logs in. Show a "History" tab with the items marked as `SENT`.

‚Ä¢ Make these items **Read-Only**. The user can View them or Delete them, but cannot Edit them (since they were already emailed).

‚Ä¢ Allow the user to click the "Pulse" ring to reset the timer and start creating **new** items.

‚Ä¢ **Case 2: User returns after Day 8 (Data is Deleted)**

‚Ä¢ The user logs in. The Vault is empty.

‚Ä¢ Show a log entry: "Protocol Executed on [Date]. Data permanently erased."

‚Ä¢ The User Account is **still active**. They do not need to sign up again. They simply reset the timer and start fresh with a new vault.

---

## **9. The Web Viewer (Vercel)**

‚Ä¢ This is a static HTML/JS page.

‚Ä¢ **Function:** It takes the Decryption Key (typed by the beneficiary), fetches the encrypted blob from Supabase, and uses Javascript to decrypt it **inside the browser**.

‚Ä¢ **Download:** Include a button allowing the beneficiary to download the decrypted Text (.txt) or Audio (.mp3) file to save the memory.

---

###Important Things:###

#### 1: How to handle "Multiple Vaults" & Editing

‚Ä¢ Don't overcomplicate it. You don't want "Multiple Timers" (that is confusing). I want One Timer Per user (The Heartbeat) that controls Multiple Boxes.

‚Ä¢ The Architecture:

‚Ä¢ The User (Master Lock): The user has one check-in timer (e.g., "I am alive").

‚Ä¢ The Items (The Boxes): Inside the app, the user sees a list. They can add as many "Items" as they want.

‚Ä¢ Item 1: Text Note ("Crypto Keys") -> Set to: Destroy.

‚Ä¢ Item 2: Audio ("For Wife") -> Set to: Send to Wife.

‚Ä¢ Item 3: Text Note ("Secret recipe") -> Set to: Send to Brother.

#### 2: How "Edit/Delete" works with Encryption: Since everything is encrypted, you can't just "edit a word."

‚Ä¢ Unlock: User clicks the item. App decrypts it locally so they can see it.

‚Ä¢ Edit: User types new text.

‚Ä¢ Save: The App re-encrypts the whole thing (generating a new random noise blob) and overwrites the old row in Supabase.

‚Ä¢ Delete: Simple. The App tells Supabase DELETE FROM vault_entries WHERE id = XYZ. It is gone forever.

#### 3: Preventing "Mods" (Anti-Tamper Strategy)

‚Ä¢ Worried someone will download your APK, modify it to bypass the "Payment" screen, or try to steal data.

‚Ä¢ The Truth: You cannot 100% prevent someone from modifying the APK (e.g., WhatsApp mods exist). BUT, you can make it useless for them.

‚Ä¢ Rule 1: Logic on Server (The Golden Rule).

‚Ä¢ Never put logic like if (user_paid) { unlock_audio } solely in the app code.

‚Ä¢ Instead, use Row Level Security (RLS) in Supabase.

‚Ä¢ Policy: "Only allow INSERT into audio_table if user.subscription_status = 'premium'."

‚Ä¢ If a modded app tries to upload audio for a free user, Supabase will reject it with a 403 Forbidden error. The server is the gatekeeper.

‚Ä¢ Rule 2: Flutter Obfuscation.

‚Ä¢ When you build the app for release, use the --obfuscate flag. It turns your readable code into unreadable gibberish (symbols), making it very hard for hackers to reverse-engineer.

‚Ä¢ Command: flutter build apk --obfuscate --split-debug-info=/<project-name>/<directory>

#### 4: The Timer tracks YOU, not the files.

‚Ä¢ Think of it like a **building with a security guard.**

‚Ä¢ * The **Timer** is the Guard.

‚Ä¢ * The **Files** (Texts/Audios) are the boxes in the secure room.

‚Ä¢ * The **Creation Date** doesn't matter.

### **How it works in practice:**

‚Ä¢ 1. **Day 1:** You sign up and set your timer to **30 Days**. You add a text note ("Bank Password").

‚Ä¢ * *System says:* "Okay, if I don't see Tejasvi by **Day 31**, I unlock everything."

‚Ä¢ 2. **Day 15:** You open the app to add a new note ("Love letter").

‚Ä¢ * *The Magic:* Just by opening the app, **the Timer resets**.

‚Ä¢ * *System says:* "Oh, Tejasvi is here! He is alive. I am resetting the countdown. Now everything is safe until **Day 45** (Day 15 + 30)."

### **So, does it matter if I create them days apart?**

‚Ä¢ **No.**

‚Ä¢ Every time you open the app to add, edit, or just look at your vault, you are telling the system "I am still here." This protects **ALL** your items instantly.

‚Ä¢ It doesn't matter if you wrote a note 2 years ago or 2 minutes ago. As long as you checked in *recently*, the guard keeps the door locked.

---

‚Ä¢ The Python script only looks at the **User Table**. If `Tejasvi` is "Late," it executes the action for **Item 1, 2, and 3** all at once.

#### 5: Can users add multiple beneficiary emails?

‚Ä¢ Yes. The best way to do this is "Per Item" rather than "Per Profile."

‚Ä¢ Instead of having just one "Main Beneficiary" for the whole account, allow the user to define the recipient for each specific secret.

‚Ä¢ Item 1 (Bank Passwords): Send to wife@example.com

‚Ä¢ Item 2 (Crypto Keys): Send to brother@gmail.com

‚Ä¢ Item 3 (Confession): Send to bestfriend@yahoo.com

#### 6: NO email is needed in case users choose destruction after xyz time (paid users)

#### 7: The timer starts as soon as the Gmail account is made (Sign Up).

‚Ä¢ Here is why, and how it handles "Empty Vaults":

‚Ä¢ 1. The Technical Reason (Simplicity)

‚Ä¢ When a user signs in with Google, your app creates a row in the profiles database table.

‚Ä¢ That row has a column: last_check_in.

‚Ä¢ By default, this is set to NOW() (the moment of sign-up).

‚Ä¢ Therefore, the countdown starts immediately from Day 1.

‚Ä¢ 2. The "Empty Vault" Scenario

‚Ä¢ You might be wondering: "What if they sign up, add nothing, and then forget the app? Will it send a blank email to no one?"

‚Ä¢ No. Your Python script handles this automatically with the logic we defined:

‚Ä¢ The Timer runs out (User is "Late").

‚Ä¢ The Script looks for Vault Items.

‚Ä¢ If Vault is Empty: The script finds 0 items to send. It simply marks the user as "Inactive" and does nothing. No emails are sent. No one is bothered.

#### 8: 1. "Even if note is deleted, it doesn't affect the timer?"

‚Ä¢ Correct. The timer watches YOU, not your notes.

‚Ä¢ You can add 50 notes and delete all of them. The timer keeps ticking based on when you last logged in. It doesn't care if the vault is full or empty.

‚Ä¢ 2. "If they delete everything, script sends nothing?"

‚Ä¢ Correct. This prevents the "Empty Email" embarrassment.

‚Ä¢ Scenario: You set a timer. You add a note. You get angry and delete the note. You disappear.

‚Ä¢ Result: The timer runs out. The script wakes up. It looks inside your vault and sees 0 Items. It shuts down without sending a single email.

‚Ä¢ 3. "If they make a note on Day 29, does the timer restart?"

‚Ä¢ Correct. This is the core "Check-in" mechanic.

‚Ä¢ Day 1: Timer starts (30 Days left).

‚Ä¢ Day 29: You open the app to write a new note.

‚Ä¢ The Magic: As soon as the app opens, it updates your last_check_in to Now.

‚Ä¢ Result: Your new deadline is 30 Days from today. You are safe until Day 59.

#### 9: This is the final set of "Edge Case" questions that define the difference between a buggy app and a professional platform.

‚Ä¢ Here is exactly how we handle the **Decryption Key**, **Editing**, **Post-Death Cleanup**, and the **"False Alarm"** scenario.

### **1. The "Trust" Problem: Can *I* (the Admin) unlock their data?**

‚Ä¢ **The Hard Truth:** If your Python script needs to email the key to the beneficiary, then your system **must** technically have access to that key.

‚Ä¢ * **"What if I unlock it?"** Yes, technically, if you are a malicious admin with full database access and the encryption keys, you *could*.

‚Ä¢ * **How to protect yourself (and the user):** You implement **"Encryption at Rest"** for the Key itself.

‚Ä¢ * **The Setup:** The User's device generates a random **Data Key**. This key encrypts their secret.

‚Ä¢ * **The Storage:** You do **not** store the Data Key plainly in Supabase. You encrypt the *Key itself* using a **Master Server Secret** (which you hide in GitHub Secrets, not the database).

‚Ä¢ * **The Result:** If you look at your Supabase database, you see:

‚Ä¢ * `Secret_Message`: `ksjdf8723kjsd...` (Gibberish)

‚Ä¢ * `Decryption_Key`: `98234lkjfsd...` (Gibberish)

‚Ä¢ * **The Safety:** You cannot read it just by looking at the table. The only thing that can read it is the **Python Script** during the official execution process. This prevents "accidental" snooping.

### **2. What if the user Edits or Deletes?**

‚Ä¢ This is standard "CRUD" (Create, Read, Update, Delete) logic, but with security rules.

‚Ä¢ **User Edits Text:** The App decrypts the old text -> User types new text -> App re-encrypts it -> Overwrites the row in Supabase.

‚Ä¢ **User Edits Email:** Simple update to the `recipient_email` column.

‚Ä¢ **User Deletes Item:**

‚Ä¢ **Text:** Instantly `DELETE` the row. It is gone forever.

‚Ä¢ **Audio:** Instantly `DELETE` the file from Storage bucket **AND** the row from the database.

‚Ä¢ **Safety:** You don't keep backups of deleted user data. Once they delete, it must be truly gone.

### **3. The "Death" Lifecycle: What happens *after* the email sends?**

‚Ä¢ We need a clean "Cleanup Protocol" so you aren't storing dead people's data forever (and paying for it).

‚Ä¢ **The Timeline:**

‚Ä¢ 1. **Day 0 (Deadline):** Script runs. Detects user is late.

‚Ä¢ 2. **Action:** Sends the Email with the Key + Link.

‚Ä¢ 3. **Immediate Step:** The script updates the item status from `Active` to `Sent` (or `Released`).

‚Ä¢ 4. **Day 7 (The Grace Period):** We keep the data for **7 Days** just in case the email went to Spam and the beneficiary needs us to resend it.

‚Ä¢ 5. **Day 8 (The Purge):** The script runs a "Cleanup" job. It finds all items marked `Sent` > 7 days ago.

‚Ä¢ * It **permanently deletes** the encrypted text/audio files.

‚Ä¢ * It **keeps** the User Profile (row) but marks it as `Archived`.

‚Ä¢ * *Why keep the profile?* So if the user (who might not be dead, just in a coma) wakes up 6 months later, they can log in and see: *"Status: Account Archived. Messages Sent on Jan 22."*

### **4. The "False Alarm" (The User comes back alive)**

‚Ä¢ Suppose the user was just stranded on an island, missed the deadline, and the emails were sent.

‚Ä¢ **Scenario:** Emails sent on Monday. User logs in on Wednesday.

‚Ä¢ **Login:** They **CAN** still log in. We never delete their account/login ability, only the *Vault Data*.

‚Ä¢ **The View:** They see an empty vault (or a log saying "Sent to Wife").

‚Ä¢ **The Reset:**

‚Ä¢ They click "I AM ALIVE."

‚Ä¢ The system sets their status back to `Active`.

‚Ä¢ The Timer resets.

‚Ä¢ They can create **new** notes.

‚Ä¢ *Note:* The old notes are gone (sent/scheduled for delete). They cannot "un-send" the email, but they can secure their account for the future.

---

### **Final Updated Logic 

> **6. Security & Cleanup Protocols (CRITICAL)**
> * **Key Storage (The "Blind Admin" Rule):**
> * The `decryption_key` for each vault item must be stored in the database **Encrypted**, using a `SERVER_SECRET` (AES) that is stored ONLY in **GitHub Secrets** and the **Flutter App Build Env**. It must NOT be visible as plain text in the Supabase Table.
> * *Goal:* I (the admin) should see only gibberish in the database. Only the App (for the user) and the Script (for the beneficiary) can unlock it.
> 
**If the data is still on the server (Day 1-7), the user SHOULD be able to see it.**

### **The Correct "Lazarus" Logic (User Comes Back Alive)**

‚Ä¢ If the user logs in **after** the email was sent (Monday) but **before** the 7-day deletion (Next Monday):

‚Ä¢ 1. **Login:** They log in successfully.

‚Ä¢ 2. **The Dashboard:** They see a big **Red Alert**: *"Protocol Executed on Monday. Emails have been sent."*

‚Ä¢ 3. **The Data:**

‚Ä¢ * **Old Logic (Wrong):** Vault is empty.

‚Ä¢ * **New Logic (Correct):** They see their items marked as **"SENT / ARCHIVED"**.

‚Ä¢ * **Can they edit?** **No.** (It‚Äôs already emailed; editing now changes nothing for the recipient).

‚Ä¢ * **Can they view?** **Yes.** (It‚Äôs still on the server).

‚Ä¢ * **Can they delete?** **Yes.** (If they want to scrub it immediately before the 7-day auto-purge).

> **6. Security & Cleanup Protocols (CORRECTED)**
> * **Post-Send Retention (7-Day Wipe):**
> * When the script sends the data to the beneficiary, change the Vault Item status from `ACTIVE` to `SENT`.
> * **Do not delete immediately.** Keep the encrypted data for **7 Days**.
> * **Auto-Deletion Job:** Create a scheduled job that runs daily: `DELETE FROM vault_entries WHERE status = 'SENT' AND sent_at < (NOW() - 7 DAYS)`.
> 
> 
> * **The "Lazarus" Scenario (User Returns Early):**
> * If a user logs in **during the 7-day retention period**:
> * **Do NOT show an empty vault.**
> * Show the `SENT` items in a "History" or "Archive" section.
> * **Restriction:** Make these items **Read-Only** (since they were already emailed). The user can view them or delete them, but cannot edit them.
> * **Reset:** Allow the user to click "I AM ALIVE" to reset their timer and start creating **new** `ACTIVE` items for the future.
> 
‚Ä¢ Now the logic holds up:

‚Ä¢ * **Monday:** Sent.

‚Ä¢ * **Wednesday:** User logs in -> Sees "Sent" items (Read Only).

‚Ä¢ * **Next Monday:** Data is deleted forever -> Vault History shows "Expired/Deleted."

#### 10: The Data (Vault Items): Ephemeral. If the timer dies, the data dies (after 7 days). 

‚Ä¢ The User (Account): Permanent. Their login, their name, and their "Active/Inactive" status stays in your database forever (unless they manually choose "Delete Account").

#### 11: keep an option for user to choose to permanently delete account which wipes all data

#### 12: The "Day 8+" Scenario (After Permanent Deletion)

‚Ä¢ Scenario: The user was gone for 40 days. The email was sent. The 7-day grace period passed. The data was scrubbed. The user logs in on Day 45.

‚Ä¢ Can they create new stuff? YES.

‚Ä¢ Do we delete their account? NO. Never delete the account (the profiles row).

‚Ä¢ What do they see?

‚Ä¢ They see a Clean Slate.

‚Ä¢ Ideally, show a "History Log" or "Activity" tab that says: "Protocol Executed on [Date]. Data permanently erased."

‚Ä¢ They click "Reset Timer" and start over from scratch with a fresh vault.

‚Ä¢ This is critical because it retains your user base. Even if they "died" (digitally), they can be "reborn" as a customer without signing up again.

#### 13: ONLY send email warning before data is sent or deleted to paid users but in case vault is empty, there is no point, only send even if one data exists

#### 14: 1. "Destroy" Action (Protocol Zero)

‚Ä¢ "If we delete rows immediately, doesn't it delete data?"

‚Ä¢ YES. That is the point.

‚Ä¢ Who uses this? Journalists, activists, or people with secrets they never want anyone to see (e.g., private chats, incriminating documents).

‚Ä¢ The Goal: If they get arrested or die, they want this data to vanish from the face of the earth.

‚Ä¢ The Outcome: The script deletes the row. No email is sent. The data is gone forever. Beneficiaries get nothing.

‚Ä¢ 2. "Send" Action (Legacy Mode)

‚Ä¢ "And how will we send beneficiary all data?"

‚Ä¢ This is the opposite of Destroy.

‚Ä¢ The Outcome: The script DOES NOT delete the data immediately.

‚Ä¢ The Step: It changes the status to SENT.

‚Ä¢ The Email: It sends the Encryption Key and a Link to the beneficiary.

‚Ä¢ The Deletion: It waits 7 Days, then deletes the data.

‚Ä¢ 3. The Vercel Site (The "Magic Decoder")

‚Ä¢ "How will the Vercel site be like?"

‚Ä¢ You cannot just email the beneficiary the data directly because it is encrypted.

‚Ä¢ If you email them the text, it looks like this: U2FsdGVkX1+98234...

‚Ä¢ Your grandma/wife cannot read that.

‚Ä¢ The Solution: The Vercel Website is a Secure Viewer.

‚Ä¢ What the Beneficiary Sees (The User Flow):

‚Ä¢ The Email:

‚Ä¢ "Tejasvi has left you a secure message. To view it, click the link below and enter this Security Key: BLUE-HORSE-99" [ OPEN VAULT ] (Button)

‚Ä¢ The Website (Vercel):

‚Ä¢ They click the link. It opens view.afterword-app.com.

‚Ä¢ The Look: Very clean. Black background. A white box in the center.

‚Ä¢ The Prompt: "Please enter the Security Key from your email."

‚Ä¢ The Magic (Decryption):

‚Ä¢ They type BLUE-HORSE-99.

‚Ä¢ They hit "Unlock."

‚Ä¢ Crucial Tech Part: The website takes the Encrypted Data from your server, mixes it with the Key they just typed, and decrypts it right there in their browser.

‚Ä¢ The Reveal: The gibberish turns into: "Hey honey, the bank account password is..." or plays the Audio file.

#### 15: Can the Admin (You) see the Beneficiary Email?

‚Ä¢ "Else I'll just edit emails to mine"

‚Ä¢ The Risk: You are right. If the database shows recipient_email: wife@gmail.com in plain text, a corrupt employee (or you) could change it to me@hacker.com, wait for the timer, and steal the key.

‚Ä¢ The Fix: Encrypt the Metadata (The "Blind Courier" System). We will instruct the developer to Encrypt the Email Address before saving it to the database.

‚Ä¢ How it works:

‚Ä¢ App: User types wife@gmail.com. App encrypts it -> U2FsdGVkX1... -> Saves to DB.

‚Ä¢ Database: You (looking at the dashboard) only see gibberish. You cannot edit it because you don't know the encryption format.

‚Ä¢ The Script: The Python script has a special "Master Key" (hidden in GitHub Secrets). It decrypts the email only for the split second it needs to send the message via Resend.

‚Ä¢ Result: You cannot see who the recipient is, and you cannot edit it to your own email without breaking the encryption.

‚Ä¢ 2. Is the Audio Encrypted?

‚Ä¢ Yes. It is white noise.

‚Ä¢ The Process:

‚Ä¢ Record: The app records the voice note (e.g., .m4a).

‚Ä¢ Scramble: Before uploading, the app takes the file's "bytes" and scrambles them using AES encryption.

‚Ä¢ Upload: The file uploaded to Supabase is basically a block of static noise.

‚Ä¢ The Protection: If you (Admin) download the file and try to play it in VLC Player, it will say "File Corrupted / Error." It is unplayable without the key.

‚Ä¢ 3. Can the Beneficiary Download?

‚Ä¢ Yes. On the Vercel "Web Viewer," once the Javascript decrypts the data, we will generate a temporary Download Button.

‚Ä¢ Text: "Download as .txt"

‚Ä¢ Audio: "Download as .mp3"

#### 16: he Vulnerability: You are 100% correct. If you (the Admin) have access to the database, you could technically:

‚Ä¢ Go to the vault_entries table.

‚Ä¢ Find a row with recipient_email (Encrypted).

‚Ä¢ Delete that string and paste your own encrypted email string.

‚Ä¢ Wait for the script to run.

‚Ä¢ The script sends the "Key" and "Data Link" to YOU instead of the wife.

‚Ä¢ The Fix: "Cryptographic Binding" (The Wax Seal) We prevent this by making the Data and the Email inseparable. We use a technique called HMAC (Hash-Based Message Authentication Code).

‚Ä¢ How "Binding" Stops You (The Admin)

‚Ä¢ When the User's App (Flutter) saves an item, it does a special math calculation on the phone:

‚Ä¢ The Formula: It takes the Encrypted_Data + Recipient_Email and mixes them together using the User's Password (which you don't have).

‚Ä¢ Signature = Hash(Data + Email + User_Secret)

‚Ä¢ The Storage: It saves this Signature in the database row.

‚Ä¢ The Check (Your Script): When your Python script tries to send the email, it runs the same math:

‚Ä¢ It looks at the Email in the DB.

‚Ä¢ It looks at the Data in the DB.

‚Ä¢ It calculates the Signature.

‚Ä¢ The Trap: If YOU changed the Email in the database, the Signature will not match.

‚Ä¢ The Result: The script sees the mismatch, logs "TAMPERING DETECTED," and refuses to send the email.

‚Ä¢ Conclusion: You can destroy the data (by messing with the table), but you cannot steal it (redirect it), because you cannot generate a valid Signature for your new email address without the user's password.

#### 17: Restricting the "Warning Email" to Paid Users does two things:

‚Ä¢ Reduces your costs to almost $0. (Free users cost you literally nothing now).

‚Ä¢ Creates a powerful upsell. "Don't trust your phone notifications? Get the Email Fail-Safe for $1.99."

‚Ä¢ Here are the answers to your questions and the final polish for the developer.

‚Ä¢ 1. Can I keep the Email Reminder for Paid Users only?

‚Ä¢ Yes.

‚Ä¢ Free Users: Rely 100% on Local Notifications. If their battery dies or they ignore the notification, the protocol executes. It is "High Risk, Free Reward."

‚Ä¢ Paid Users (Pro/Lifetime): Get the Server-Side Email Warning. This is the "Insurance Policy." Even if their phone is lost in a river, they get the email on their laptop.

‚Ä¢ 2. Should I add more features?

‚Ä¢ No. Stop. Your app is currently Perfectly Balanced.

‚Ä¢ It solves one problem (Dead Man's Switch).

‚Ä¢ It has three distinct tiers (Text, Destruction, Audio).

‚Ä¢ It is simple to build.

‚Ä¢ If you add more:

‚Ä¢ GPS Tracking: Privacy nightmare. Users will trust you less.

‚Ä¢ Social Verifiers: Too complex. "My friend didn't verify me!" -> Bugs.

‚Ä¢ Video: Too expensive for storage.

‚Ä¢ Stick to the current plan. Launch it. Get 10,000 users. Then ask them what they want.

‚Ä¢ 3. The "I AM ALIVE" Button (Aesthetic Upgrade)

‚Ä¢ You are right. "I AM ALIVE" feels a bit panic-inducing. Let's make it Cinematic and Abstract.

‚Ä¢ The Concept: "The Pulse"

‚Ä¢ Name: Don't use text. Use a visual.

‚Ä¢ The Icon: A simple, thin Ring or Fingerprint icon in the center of the screen.

‚Ä¢ Animation: It "breathes" (slowly fades in and out) with an Amber glow.

‚Ä¢ Action: Long Press (Hold) to check in.

‚Ä¢ Why Long Press? It feels intentional. A tap is accidental. A hold is a conscious choice.

‚Ä¢ Feedback: As they hold, the ring fills up. When full -> Haptic Vibration -> "Signal Received."

---------------------------------------------------------------

## Finally This:

I asked an expert what could possibly go wrong with my app, here is the list.

So, make sure to keep my app safe.

# A ‚Üí Z: Everything that can go wrong (no fixes)

## A

* **Admin abuse** ‚Äî privileged person edits DB, changes recipient, reads metadata.
* **API abuse** ‚Äî unauthenticated or abused endpoints used to enumerate or dump data.
* **Account takeover** ‚Äî OAuth/credentials stolen, attacker controls account.
* **Automation abuse** ‚Äî attacker triggers or manipulates the python automation.
* **Asymmetric key mismanagement** ‚Äî private keys exposed or mixed up.
* **Aging backups leakage** ‚Äî old backups contain keys/plaintext.
* **Ambiguous state transitions** ‚Äî items stuck in limbo (PENDING/FAILED/etc).
* **Availability outages** ‚Äî services (Supabase/Resend/Vercel) down.

## B

* **Backup resurrection** ‚Äî deleted data returns from restores.
* **Brute-force on web viewer** ‚Äî guessing decryption keys or tokens.
* **Broken idempotence** ‚Äî repeated script runs cause duplication or lost state.
* **Business-logic bugs** ‚Äî wrong users get access from logic errors.
* **Billing fraud** ‚Äî payment/service abuse or chargebacks.
* **Broken crypto libs** ‚Äî vulnerable or outdated cryptography libs used.

## C

* **Credential leakage** ‚Äî secrets in logs, CI, or builds.
* **Clock/timestamp attacks** ‚Äî time tampering on device or server.
* **Canonicalization mismatch** ‚Äî HMACs fail due to different encoding.
* **Cross-site scripting (XSS)** on web viewer.
* **Cross-origin (CORS) misconfig** allowing data access.
* **Corrupted uploads** ‚Äî partial or malformed encrypted data stored.
* **Concurrent edits** causing inconsistent HMAC/versions.

## D

* **Double-send** ‚Äî email sent twice due to race or replay.
* **Data-remnant in caches** ‚Äî CDN, browser cache, or proxies keep copies.
* **Deleted-but-backed-up** ‚Äî ‚Äúdeleted‚Äù items present in snapshots.
* **Destructive automation bug** ‚Äî mass-delete due to bad filter.
* **Disclosure via email headers** ‚Äî sensitive metadata in message headers.
* **Dependency compromise** ‚Äî malicious npm/pip package in build.

## E

* **Endpoint exposure** ‚Äî admin or internal endpoints reachable publicly.
* **Encryption misuse** ‚Äî wrong mode/IV/nonce reuse or absent AEAD.
* **Escrow/ownership ambiguity** ‚Äî who legally controls keys/data.
* **Email spoofing** ‚Äî attackers forge emails to beneficiaries.
* **Error logging leaks** ‚Äî stack traces contain secrets.

## F

* **Forked workflows / replayed CI** ‚Äî attacker replays historical GitHub Actions.
* **Failed rollbacks** ‚Äî partial rollbacks leave system inconsistent.
* **File orphaning** ‚Äî storage objects without DB rows.
* **Flooding / DoS** ‚Äî create accounts/upload floods to exhaust resources.
* **Forensic traces** ‚Äî inadequate audit trail for incident review.

## G

* **Git secrets leakage** ‚Äî secrets committed to repo or PRs.
* **Garbage collection gaps** ‚Äî deleted objects persist in cold storage.
* **Granularity mistakes** ‚Äî overly broad DB privileges or policies.
* **Geo-jurisdiction exposure** ‚Äî storing data in wrong legal region.

## H

* **HMAC key compromise** ‚Äî attacker forges signatures or bypasses binding.
* **Hijacked webhook** ‚Äî attacker intercepts or fakes webhook calls.
* **Human error** ‚Äî support staff accidentally changes data.
* **Hard-coded secrets** in mobile builds or frontend bundles.

## I

* **Idempotency failures** ‚Äî non-repeat-safe operations produce double actions.
* **Injection vulnerabilities** ‚Äî SQL/command injection in inputs or scripts.
* **Insider social engineering** ‚Äî staff tricked into exposing access.
* **Insecure temporary files** on device/server containing plaintext.

## J

* **Jurisdictional contradiction** ‚Äî data laws conflict across regions.
* **JWT misuse** ‚Äî poorly validated tokens accepted, allowing impersonation.
* **Job scheduling mistakes** ‚Äî cron / GitHub Actions mis-timed or misconfigured.

## K

* **Key rotation breakage** ‚Äî rotated keys render stored data unreadable.
* **KMS compromise** ‚Äî KMS account hijacked exposing key material.
* **Key leakage in CI logs** ‚Äî secrets printed in build logs.

## L

* **Leaked decryption keys in email** ‚Äî keys sent in subject/body or URL.
* **Liveness checks tampered** ‚Äî attacker manipulates ‚ÄúI am alive‚Äù signal.
* **Lack of monitoring** ‚Äî automation fails silently with no alerts.
* **Local-device compromise** ‚Äî rooted/jailbroken phone exposing keys.

## M

* **MitM during transport** ‚Äî TLS misconfig allowing interception.
* **Malformed ciphertext** ‚Äî decryption fails unexpectedly and is unrecoverable.
* **Metadata leakage** ‚Äî filenames, sizes, counts reveal secrets.
* **Missing consent/legal docs** ‚Äî legal exposure for irrevocable deletes.

## N

* **Nonce/IV reuse** causing ciphertext compromises.
* **Noisy telemetry leaks** ‚Äî analytics reveal usage/patterns.
* **Notification abuse** ‚Äî spamming or notification content leaking state.
* **Network partition** leading to split-brain on status updates.

## O

* **Orphaned DB rows** referencing removed objects.
* **Over-privileged service accounts** used by automation.
* **Operational blindspots** ‚Äî no SLOs, no on-call, no runbooks.
* **Open redirect** on web viewer leading to phishing.

## P

* **Phishing of beneficiaries** imitating Afterword emails.
* **Presigned URL errors** ‚Äî long-lived or public URLs granting access.
* **Permission misconfig** in Supabase buckets exposing files.
* **Payment system failure** causing incorrect access changes.

## Q

* **Quota exhaustion** ‚Äî storage/email limits reached due to abuse.
* **Quality/consistency drift** ‚Äî test coverage misses edge cases.
* **Query performance collapse** ‚Äî script slow or times out on large data.

## R

* **Replay attacks** ‚Äî automation replay or message replay causes re-exec.
* **Race conditions** ‚Äî edit vs automation causes wrong payloads sent.
* **Resend provider failure** ‚Äî email provider outage without detect.
* **RLS bypass** ‚Äî Row-Level Security misconfigured allowing reads/writes.

## S

* **Supply chain compromise** ‚Äî malicious dependency in build chain.
* **Script RCE potential** ‚Äî unsafe deserialization or shell invocation.
* **Side-channel leaks** ‚Äî timing/padding/oracle attacks revealing plaintext.
* **Socket/exposed DB ports** accessible publicly.
* **Snooping by cloud admins** ‚Äî privileged cloud staff access.

## T

* **Time calculation bugs** ‚Äî off-by-one-day, DST, timezone errors.
* **Tamper detection false positives** ‚Äî canonicalization mismatch causing false alarms.
* **Third-party data leak** ‚Äî analytics or plugins leak PII.
* **Token brute force** ‚Äî insufficient token entropy or rate limits.

## U

* **Unauthorized mass deletes** ‚Äî accidental or malicious bulk deletions.
* **Unencrypted metadata** ‚Äî emails/recipient stored plaintext.
* **Unvalidated inputs** causing injection or malformed actions.
* **Unrecoverable corruption** ‚Äî bad writes permanently corrupting data.

## V

* **Version skew** ‚Äî app and script have incompatible crypto/version behavior.
* **Vulnerability windows** ‚Äî long delays between vulnerability discovery and patch.
* **Visibility gaps** ‚Äî no audit trail for specific destructive ops.
* **Vendor lock-in failure modes** ‚Äî provider outage impacting core flows.

## W

* **Weak randomness** ‚Äî predictable tokens or keys.
* **Wrong side-effects** ‚Äî send triggers deletion due to bad flag logic.
* **Web viewer XSS/CSP bypass** exposing decrypted content.
* **Webhook replay or forged webhook** executing unauthorized flows.

## X

* **XML external entity (XXE)** through any XML parsing in stack.
* **X-Forwarded-For spoofing** causing incorrect IP-based logic.
* **XSS via beneficiary input** (if any rich text allowed).

## Y

* **Year/Date edge cases** ‚Äî leap years, leap seconds causing expiry mismatch.
* **Young users / minors** storing sensitive material without guardian consent.
* **Yielding to dependency failures** ‚Äî system silently tolerates degraded crypto libs.

## Z

* **Zero-day exploit** in any dependency leading to mass compromise.
* **Zombie processes** replaying old automation actions after restore.
* **Zone misconfiguration** ‚Äî DNS mispointing exposing staging/prod.
* **Zero-visibility admin actions** ‚Äî no logging of who triggered destructive ops.

----------------------------------------------------------------------------------------
MAKE SURE ALL RISKS ARE WORKED UPON TOO:

Risk #1: Version skew (App vs Script)

If Flutter encrypts one way and Python decrypts slightly differently:

Boom ‚Üí permanent data loss

No recovery

Users rage

üî• Risk #2: Time bugs

DST. Timezones. Device clock lies.

You already did the right thing by:

Trusting server time for execution

Using device only for local reminders

But be strict:

last_check_in must be server-side timestamp

script must treat time as UTC-only

No exceptions.

üî• Risk #3: Web Viewer brute force

Humans choose trash keys unless you force entropy.

If someone can:

Guess keys

Hammer the viewer

Then encryption means nothing.

----------------------------------------------------------------------------------------------

#Important
ALL KEYS AS OF NOW:

1: Supabase (database + auth)
URL: https://abxduxfiwhsjsqicrbru.supabase.co
About keys: Supabase has updated it's API keys
Publishable key
This key is safe to use in a browser if you have enabled Row Level Security (RLS) for your tables and configured policies. Key is: sb_publishable_lrcX0avT41YrDEWI30mRaw_FHNqg22j

Secret keys
These API keys allow privileged access to your project's APIs. Use in servers, functions, workers or other backend components of your application. Key is: sb_secret_Lj5mljs9Kx6Sqmr7MysIlg_Mxqx3sSn

2: Resend API key: re_EE2SaxsF_KwCnJnH2cJ9pbVNtV3ebthQZ
My domain is verified here: https://afterword-app.com/

5: Revenue Cat has this thing: It says: Using AI to integrate RevenueCat? I copy pasted that below.
Help me integrate RevenueCat SDK into my AfterWord app. I need to:

1. Install the RevenueCat SDK using Pub
   - Pub: flutter pub add purchases_flutter purchases_ui_flutter
   - Documentation: https://www.revenuecat.com/docs/getting-started/installation/flutter#installation

2. Configure it with my API key: test_jWwyCIqOWRKhJCzByTVXQMyAHue

3. Set up basic subscription functionality in Flutter

4. Set up entitlement checking for: AfterWord Pro

5. Handle customer info and purchases

6. Configure products for my app:
- Monthly (monthly)
- Yearly (yearly)
- Lifetime (lifetime)

Please provide step-by-step instructions for Flutter implementation with Pub. Include:

- Complete code examples

- Error handling

- Best practices for subscription management

- Customer info retrieval

- Entitlement checking for AfterWord Pro

- Present a RevenueCat Paywall (https://www.revenuecat.com/docs/tools/paywalls)

- When it makes sense: Add support for Customer Center (https://www.revenuecat.com/docs/tools/customer-center)

- Product configuration and offering setup

- Make sure to implement it all using the best modern methods supported by the RevenueCat SDK.

Here is code: import 'package:purchases_flutter/purchases_flutter.dart';
import 'dart:io';

Future<void> initializeRevenueCat() async {
  // Platform-specific API keys
  String apiKey;
  if (Platform.isIOS) {
    apiKey = 'test_jWwyCIqOWRKhJCzByTVXQMyAHue';
  } else if (Platform.isAndroid) {
    apiKey = 'test_jWwyCIqOWRKhJCzByTVXQMyAHue';
  } else {
    throw UnsupportedError('Platform not supported');
  }
  
  await Purchases.configure(PurchasesConfiguration(apiKey));
}

It also says: Integrate the SDK
Add RevenueCat to your app. Copy your API key, use the sample code, or set up with AI prompts.

API KEY:

test_jWwyCIqOWRKhJCzByTVXQMyAHue

--------------------------------------------------------------------------------

